package ar.edu.unnoba.compilador;

import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.List;
import java.io.FileReader;
import java.util.logging.Level;
import java.util.logging.Logger;

class MiParser;

parser code
{:
    public void syntax_error(Symbol s){
        System.out.println("Error en la linea "+ (s.left+1)+ " Columna "+ s.right+ ". Valor simbolo '"
        +s.value+"' . Simbolo n° "+s.sym+ " no reconocido." );
    }

    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{
        System.out.println("Error en la linea "+ (s.left+1)+ " Columna "+ s.right+ ". Valor simbolo '"
        +s.value+"' . Simbolo n° "+s.sym+ " no reconocido." );
    }

:};

terminal String IDENTIFICADOR,
    OP_ARIT_SUMA_O_RESTA, OP_ARIT_PROD_O_DIV, OP_COMPARACION,
    OP_LOG_BIN_OR, OP_LOG_BIN_AND, OP_LOG_UNA_NOT,
    PAR_ABRE, PAR_CIERRA, PR_IF, PR_THEN, PR_ELSE, PUNTO_Y_COMA, IGUAL,
    PR_VARIABLE, PR_IS,
    TIPO_DE_DATO, CTE_BOOLEANA, ENTERO, FLOTANTE;

nonterminal String programa,
    estructura_condicional_if,
    sentencia, asignacion, expresion, comparacion, termino,
    expresion_logica_or, expresion_logica_and,
    op_aritmetica_suma_resta, op_aritmetica_producto_division,
    numero_constante;

// Precedencia de operadores. Ni idea si está bien así, todavía no lo puedo probar
// FIXME: operador unario "-", ¿cómo diferenciarlo de la resta?
precedence left OP_LOG_BIN_OR, OP_ARIT_SUMA_O_RESTA;
precedence left OP_LOG_BIN_AND, OP_ARIT_PROD_O_DIV;
precedence left OP_LOG_UNA_NOT;

start with programa;

// FIXME: programa::= declaracion(variables o funciones)* sentencia*
programa::= expresion;

declaracion::=
        PR_VARIABLE IDENTIFICADOR PR_IS TIPO_DE_DATO {:

        :} |
        PR_VARIABLE IDENTIFICADOR PR_IS TIPO_DE_DATO IGUAL expresion{:

        :} |
        ;

estructura_condicional_if::=  PR_IF expresion_logica_or PR_THEN sentencia PUNTO_Y_COMA
                            | PR_IF expresion_logica_or PR_THEN sentencia PR_ELSE sentencia PUNTO_Y_COMA;

// FIXME: agregar llamadas a funciones, estructuras de control y lo que haga falta
sentencia::= asignacion;
asignacion::= IDENTIFICADOR IGUAL termino;

expresion::= expresion_logica_or;
expresion::= op_aritmetica_suma_resta;

expresion_logica_or::=
        comparacion OP_LOG_BIN_OR expresion_logica_or {:
        :} |
        comparacion {:
        :}
        expresion_logica_and {:
        :} |;

expresion_logica_and::=
        comparacion OP_LOG_BIN_AND expresion_logica_and {:
        :} |
        comparacion {:
        :};

comparacion::= termino OP_COMPARACION termino;

op_aritmetica_suma_resta ::=
        termino:t1 OP_ARIT_SUMA_O_RESTA:tipo_op op_aritmetica_suma_resta:terminos_restantes {:
            RESULT = t1 + tipo_op + terminos_restantes;
            System.out.println("REGLA 10.1: op_aritmetica_suma_resta -> termino " + tipo_op + " op_aritmetica_suma_resta (" + RESULT + ")");
        :} |
        termino:t1 OP_ARIT_SUMA_O_RESTA:tipo_op termino:t2 {:
                RESULT = t1 + tipo_op + t2;
                System.out.println("REGLA 10.2: op_aritmetica_suma_resta -> termino " + tipo_op + " termino (" + RESULT + ")");
        :} |
        op_aritmetica_producto_division:terminos_restantes {:
            RESULT = terminos_restantes;
            System.out.println("REGLA 10.3: op_aritmetica_suma_resta -> op_aritmetica_producto_division (" + RESULT + ")");
        :};

op_aritmetica_producto_division ::=
        termino:t1 OP_ARIT_PROD_O_DIV:tipo_op op_aritmetica_producto_division:terminos_restantes {:
            RESULT = t1 + tipo_op + terminos_restantes;
            System.out.println("REGLA 11.1: op_aritmetica_producto_division -> termino " + tipo_op + " op_aritmetica_producto_division (" + RESULT + ")");
        :} |
        termino:t1 OP_ARIT_PROD_O_DIV:tipo_op termino:t2 {:
            RESULT = t1 + tipo_op + t2;
            System.out.println("REGLA 11.2: op_aritmetica_producto_division -> termino " + tipo_op + " termino (" + RESULT + ")");
        :};

// FIXME: el término tmb. puede ser una función que devuelvan un valor
termino::=
        numero_constante {:
            System.out.println("REGLA 5.1: termino -> numero_constante");
        :} |
        IDENTIFICADOR {:
            System.out.println("REGLA 5.2: termino -> IDENTIFICADOR");
        :} |
        CTE_BOOLEANA {:
            System.out.println("REGLA 5.3: termino -> CTE_BOOLEANA");
        :};

numero_constante::=
        ENTERO:num {:
            System.out.println("REGLA 6.1: numero_constante -> ENTERO");
            RESULT = num;
        :} |
        FLOTANTE:num {:
            System.out.println("REGLA 6.2: numero_constante -> FLOTANTE");
            RESULT = num;
        :};