package ar.edu.unnoba.compilador;

import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.List;
import java.io.FileReader;
import java.util.logging.Level;
import java.util.logging.Logger;

class MiParser;

parser code
{:
    public void syntax_error(Symbol s) {
        System.out.println("Error en la línea "+ (s.left+1)+ " Columna "+ s.right+ ". Símbolo '"
        +s.value+"'. Símbolo n° "+s.sym+ " no reconocido." );
    }

    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception {
        System.out.println("Error en la línea "+ (s.left+1)+ " Columna "+ s.right+ ". Símbolo '"
        +s.value+"'. Símbolo n° "+s.sym+ " no reconocido." );
    }

:};

terminal String PR_MAIN_IS, PR_END_PUNTO, PR_VARIABLE, PR_IS, PR_FUNCTION,
    PR_RETURN, PR_BEGIN, PR_END, PR_IF, PR_THEN, PR_ELSE, PR_WHEN, PR_WHILE,
    PR_FOR, PR_FROM, PR_TO, PR_BY, PR_DO, PR_BREAK, PR_CONTINUE,
    PR_WRITELN, PR_WRITE, PR_READ_INTEGER, PR_READ_FLOAT, PR_READ_BOOLEAN,
    TIPO_DE_DATO, CTE_BOOLEANA,
    OP_ARIT_SUMA_O_RESTA, OP_ARIT_PROD_O_DIV, OP_COMPARACION,
    OP_LOG_BIN_OR, OP_LOG_BIN_AND, OP_LOG_UNA_NOT,
    PAR_ABRE, PAR_CIERRA,
    PR_COMA, PUNTO_Y_COMA, IGUAL,
    IDENTIFICADOR, FLOTANTE, ENTERO,
    CADENA;

nonterminal String programa, lst_sentencias, lst_sentencias_fun, cuerpo, cuerpo_fun,
    lst_decs_vars_y_funcs, dec_var, dec_fun, lst_args, arg,
    estructura_condicional_if, estructura_condicional_if_else, estructura_condicional_when,
    estructura_iterativa_while, estructura_iterativa_for,
    sentencia, asignacion, operacion,
    invocacion_funcion, lst_terminos, factor,
    expresion_logica_or, expresion_logica_and, expresion_logica_not, expresion_logica_basica,
    op_aritmetica_suma_resta, op_aritmetica_producto_division,
    numero_constante;

// Precedencia de operadores. Ni idea si está bien así, todavía no lo puedo probar
// FIXME: operador unario "-", ¿cómo diferenciarlo de la resta?
precedence left OP_LOG_BIN_OR, OP_ARIT_SUMA_O_RESTA;
precedence left OP_LOG_BIN_AND, OP_ARIT_PROD_O_DIV;
precedence left OP_LOG_UNA_NOT;

// Hay un conflicto de shift/reduce en el if porque es ambiguo.
// Con esto hace el shift (busca leer lo máx. posible, o sea el else).
// FIXME: ver si se puede encontrar una regla no ambigua.
// precedence nonassoc PR_ELSE;

start with programa;
//start with expresion_logica_or;

// TODO: ver si se puede encontrar una forma coherente de numerar las reglas...
programa ::=
        lst_decs_vars_y_funcs:decs PR_MAIN_IS:is lst_sentencias:sentencias PR_END_PUNTO:end {:
            RESULT = String.join(" ", decs, is, sentencias, end);
            System.out.println("REGLA 0.1 -> lst_decs_vars_y_funcs PR_MAIN_IS lst_sentencias PR_END_PUNTO (" + RESULT + ") -> programa");
        :} |
        PR_MAIN_IS:is lst_sentencias:sentencias PR_END_PUNTO:end {:
            RESULT = String.join(" ", is, sentencias, end);
            System.out.println("REGLA 0.2 -> PR_MAIN_IS lst_sentencias PR_END_PUNTO (" + RESULT + ") -> programa");
        :} |
        lst_decs_vars_y_funcs:decs PR_MAIN_IS:is PR_END_PUNTO:end {:
            // programa con declaraciones pero sin cuerpo principal
            RESULT = String.join(" ", decs, is, end);
            System.out.println("REGLA 0.3 -> lst_decs_vars_y_funcs PR_MAIN_IS PR_END_PUNTO (" + RESULT + ") -> programa");
        :} |
        PR_MAIN_IS:is PR_END_PUNTO:end {:
            // programa "nulo"
            RESULT = String.join(" ", is, end);
            System.out.println("REGLA 0.4 -> PR_MAIN_IS PR_END_PUNTO (" + RESULT + ") -> programa");
        :};

lst_decs_vars_y_funcs ::=
        dec_var:dec_var lst_decs_vars_y_funcs:decs {:
             RESULT = String.join(" ", dec_var, decs);
             System.out.println("REGLA 1.1: dec_var (" + RESULT + ") -> lst_decs_vars_y_funcs");
        :} |
        dec_fun:dec_fun lst_decs_vars_y_funcs:decs {:
            RESULT = String.join(" ", dec_fun, decs);
            System.out.println("REGLA 1.2: dec_fun (" + RESULT + ") -> lst_decs_vars_y_funcs");
        :} |
        dec_var:dec_var {:
            RESULT = dec_var;
            System.out.println("REGLA 1.3: dec_var (" + RESULT + ") -> lst_decs_vars_y_funcs");
        :} |
        dec_fun:dec_fun {:
            RESULT = dec_fun;
            System.out.println("REGLA 1.4: dec_fun (" + RESULT + ") -> lst_decs_vars_y_funcs");
        :};

// TODO: En el caso de tratarse de una variable global, dicha expresión no deberá admitir
// invocaciones a funciones como parte de la expresión (no ocurriendo lo mismo con
// variables locales a un bloque de sentencias o función, donde dicha restricción no existe).
dec_var ::=
        PR_VARIABLE:pr_var arg:arg PUNTO_Y_COMA:pyc {:
             RESULT = String.join(" ", pr_var, arg, pyc);
             System.out.println("REGLA 1.3.1: PR_VARIABLE arg PUNTO_Y_COMA (" + RESULT + ") -> dec_var");
        :};

dec_fun ::=
        PR_FUNCTION:funcion IDENTIFICADOR:id PAR_ABRE:pa PAR_CIERRA:pc PR_RETURN:ret TIPO_DE_DATO:td cuerpo_fun:cuerpo {:
            RESULT = String.join(" ", funcion, id, pa, pc, ret, td, cuerpo);
            System.out.println("REGLA 1.4.1: PR_FUNCTION IDENTIFICADOR PAR_ABRE PAR_CIERRA PR_RETURN " +
                                "TIPO_DE_DATO cuerpo_fun (" + RESULT + ") -> dec_fun");
        :} |
        PR_FUNCTION:funcion IDENTIFICADOR:id PAR_ABRE:pa lst_args:args PAR_CIERRA:pc PR_RETURN:ret TIPO_DE_DATO:td cuerpo_fun:cuerpo {:
            RESULT = String.join(" ", funcion, id, pa, args, pc, ret, td, cuerpo);
            System.out.println("REGLA 1.4.2: PR_FUNCTION IDENTIFICADOR PAR_ABRE lst_args PAR_CIERRA " +
                                "PR_RETURN TIPO_DE_DATO cuerpo_fun (" + RESULT + ") -> dec_fun");
        :};

lst_args ::=
        arg:arg PR_COMA:coma lst_args:args {:
            RESULT = String.join(" ", arg, coma, args);
            System.out.println("REGLA 1.4.2.1: arg PR_COMA lst_args (" + RESULT + ") -> lst_args");
        :} |
        arg:arg {:
            RESULT = arg;
            System.out.println("REGLA 1.4.2.2: arg (" + RESULT + ") -> lst_args");
        :};

arg ::=
        IDENTIFICADOR:id PR_IS:is TIPO_DE_DATO:td  {:
            RESULT = String.join(" ", id, is, td);
            System.out.println("REGLA 1.3.2.1: IDENTIFICADOR PR_IS TIPO_DE_DATO (" + RESULT + ") -> arg");
        :} |
        IDENTIFICADOR:id PR_IS:is TIPO_DE_DATO:td IGUAL:igual operacion:exp {:
            RESULT = String.join(" ", id, is, td, igual, exp);
            System.out.println("REGLA 1.3.2.2: IDENTIFICADOR PR_IS TIPO_DE_DATO " +
            "IGUAL operacion (" + RESULT + ") -> arg");
        :};

cuerpo_fun ::=
        PR_RETURN:ret operacion:op PUNTO_Y_COMA:pyc {:
            RESULT = String.join(" ", ret, op, pyc);
            System.out.println("REGLA 18.1: PR_RETURN operacion PUNTO_Y_COMA (" + RESULT + ") -> cuerpo_fun");
        :} |
        // TODO Considerar sentencias que no sean return porque pueden ser por ejemplo un if con returns adentro...
        // Si no tenemos que agregar cada estructura posible acá también
        // TODO Peeero en los ifs y demás también hay que considerar los returns, ahhhhhhhg
        // O permitir return en cualquier parte del código...
        sentencia:sent PUNTO_Y_COMA:pyc {:
            RESULT = String.join(" ", sent, pyc);
            System.out.println("REGLA 18.2: sentencia PUNTO_Y_COMA (" + RESULT + ") -> lst_sentencias_fun");
        :} |
        PR_BEGIN:begin lst_sentencias_fun:sentencias PR_END:end PUNTO_Y_COMA:pyc {:
            RESULT = String.join(" ", begin, sentencias, end, pyc);
            System.out.println("REGLA 18.3: PR_BEGIN lst_sentencias_fun PR_END PUNTO_Y_COMA:pyc (" + RESULT + ") -> cuerpo_fun");
        :};

// TODO no creo que haga falta acá ver que por lo menos haya un return...
lst_sentencias_fun ::=
        sentencia:sent PUNTO_Y_COMA:pyc lst_sentencias_fun:sentencias {:
            RESULT = String.join(" ", sent, pyc, sentencias);
            System.out.println("REGLA 19.1: sentencia PUNTO_Y_COMA lst_sentencias_fun (" + RESULT + ") -> lst_sentencias_fun");
        :} |
        sentencia:sent PUNTO_Y_COMA:pyc {:
            RESULT = String.join(" ", sent, pyc);
            System.out.println("REGLA 19.2: sentencia PUNTO_Y_COMA (" + RESULT + ") -> lst_sentencias_fun");
        :} |
        PR_RETURN:ret operacion:op PUNTO_Y_COMA:pyc lst_sentencias_fun:sentencias {:
            RESULT = String.join(" ", ret, pyc, sentencias);
            System.out.println("REGLA 19.3: PR_RETURN operacion PUNTO_Y_COMA lst_sentencias_fun (" + RESULT + ") -> lst_sentencias_fun");
        :} |
        PR_RETURN:ret operacion:op PUNTO_Y_COMA:pyc {:
            RESULT = String.join(" ", ret, op, pyc);
            System.out.println("REGLA 19.4: PR_RETURN PUNTO_Y_COMA (" + RESULT + ") -> lst_sentencias_fun");
        :};

lst_sentencias ::=
        sentencia:sent PUNTO_Y_COMA:pyc lst_sentencias:sentencias {:
            RESULT = String.join(" ", sent, pyc, sentencias);
            System.out.println("REGLA 2.1: sentencia PUNTO_Y_COMA lst_sentencias (" + RESULT + ") -> lst_sentencias");
        :} |
        sentencia:sent PUNTO_Y_COMA:pyc {:
            RESULT = String.join(" ", sent, pyc);
            System.out.println("REGLA 2.2: sentencia PUNTO_Y_COMA (" + RESULT + ") -> lst_sentencias");
        :};

// sentencia simple o bloque begin/end para estructuras if, while, etc.
cuerpo ::=
        // no ponemos punto y coma acá porque puede venir el "else" de un "if"
        sentencia:sent {:
            RESULT = String.join(" ", sent);
            System.out.println("REGLA 17.1: sentencia (" + RESULT + ") -> cuerpo");
        :} |
        PR_BEGIN:begin lst_sentencias:sentencias PR_END:end {:
            RESULT = String.join(" ", begin, sentencias, end);
            System.out.println("REGLA 17.2: PR_BEGIN lst_sentencias PR_END (" + RESULT + ") -> cuerpo");
        :};

// TODO: agregar las estructuras de control e iteración que definamos
sentencia ::=
        estructura_condicional_if:estruc_if {:
            RESULT = estruc_if;
            System.out.println("REGLA 2.3.1: estructura_condicional_if (" + RESULT + ") -> sentencia");
        :} |
        estructura_condicional_if_else:estruc_if_else {:
            RESULT = estruc_if_else;
            System.out.println("REGLA 2.3.2: estructura_condicional_if_else (" + RESULT + ") -> sentencia");
        :} |
        asignacion:asig {:
            RESULT = asig;
            System.out.println("REGLA 2.3.3: asignacion (" + RESULT + ") -> sentencia");
        :} |
        invocacion_funcion:invo_fun {:
            RESULT = invo_fun;
            System.out.println("REGLA 2.3.4: invocacion_funcion(" + RESULT + ") -> sentencia");
        :} |
        estructura_iterativa_while:estruc_while {:
            RESULT = estruc_while;
            System.out.println("REGLA 2.3.5: estructura_iterativa_while (" + RESULT + ") -> sentencia");
        :} |
        // "Las variables se pueden definir en cualquier punto del programa"
        PR_VARIABLE:pr_var arg:arg {:
            RESULT = String.join(" ", pr_var, arg);
            System.out.println("REGLA 2.3.6: PR_VARIABLE arg (" + RESULT + ") -> sentencia");
        :};

// TODO terminar de ver el tema de los dos puntos si hay una estructura dentro de otra
estructura_condicional_if ::=
        PR_IF:pr_if expresion_logica_or:or PR_THEN:pr_then cuerpo:cuerpo PUNTO_Y_COMA:pyc {:
            RESULT = String.join(" ", pr_if, or, pr_then, cuerpo, pyc);
            System.out.println("REGLA 3.1: PR_IF expresion_logica_or PR_THEN cuerpo PUNTO_Y_COMA ("
            + RESULT + ") -> estructura_condicional_if");
        :};

estructura_condicional_if_else ::=
        PR_IF:pr_if expresion_logica_or:or PR_THEN:pr_then cuerpo:cuerpo1 PR_ELSE:pr_else cuerpo:cuerpo2 {:
            RESULT = String.join(" ", pr_if, or, pr_then, cuerpo1, pr_else, cuerpo2);
            System.out.println("REGLA 3.2: PR_IF expresion_logica_or PR_THEN cuerpo PR_ELSE cuerpo ("
            + RESULT + ") -> estructura_condicional_if_else");
        :};

// 14
estructura_condicional_when ::=;

// 15
// while <condición> do <sentencia>;
estructura_iterativa_while ::=
        PR_WHILE:pr_while expresion_logica_or:exp_or PR_DO:pr_do cuerpo:cuerpo {:
            RESULT = String.join(" ", pr_while, exp_or, pr_do, cuerpo);
            System.out.println("REGLA 15.1: PR_WHILE expresion_logica_or PR_DO sentencia (" + RESULT + ")"
            + " -> estructura_iterativa_while");
        :};

// 16
estructura_iterativa_for ::=;

asignacion ::=
        IDENTIFICADOR:id IGUAL:igual operacion:operacion {:
            RESULT = String.join(" ", id, igual, operacion);
            System.out.println("REGLA 4: IDENTIFICADOR IGUAL operacion (" + RESULT + ") -> asignacion");
        :};

operacion ::=
        expresion_logica_or:exp_or {:
            RESULT = exp_or;
            System.out.println("REGLA 5.1: expresion_logica_or (" + RESULT + ") -> operacion");
        :} |
        op_aritmetica_suma_resta:op_arit {:
            RESULT = op_arit;
            System.out.println("REGLA 5.2: op_aritmetica_suma_resta (" + RESULT + ") -> operacion");
        :};

expresion_logica_or ::=
        expresion_logica_or:resto OP_LOG_BIN_OR:op_or expresion_logica_and:expr_and {:
            RESULT = String.join(" ", resto, op_or, expr_and);
            System.out.println("REGLA 6.1: expresion_logica_or OP_LOG_BIN_OR expresion_logica_and (" + RESULT +") -> expresion_logica_or");
        :} |
        expresion_logica_and:expr {:
            RESULT = expr;
            System.out.println("REGLA 6.2: expresion_logica_and (" + RESULT + ") -> expresion_logica_or");
        :};

expresion_logica_and ::=
        expresion_logica_and:resto OP_LOG_BIN_AND:op_and expresion_logica_not:expr_not {:
            RESULT = String.join(" ", resto, op_and, expr_not);
            System.out.println("REGLA 7.1: expresion_logica_and OP_LOG_BIN_AND expresion_logica_not (" + RESULT + ") -> expresion_logica_and");
        :} |
        expresion_logica_not:expr {:
            RESULT = String.join(" ", expr);
            System.out.println("REGLA 7.2: expresion_logica_not (" + RESULT + ") -> expresion_logica_and");
        :};

expresion_logica_not ::=
        OP_LOG_UNA_NOT:op_not expresion_logica_basica:expr_basica {:
            RESULT = String.join(" ", op_not, expr_basica);
            System.out.println("REGLA 8.1: OP_LOG_UNA_NOT expresion_logica_basica (" + RESULT + ") -> expresion_logica_not");
        :} |
        expresion_logica_basica:expr_basica {:
            RESULT = String.join(" ", expr_basica);
            System.out.println("REGLA 8.1: expresion_logica_basica (" + RESULT + ") -> expresion_logica_not");
        :};

expresion_logica_basica ::=
        factor:f1 OP_COMPARACION:op factor:f2 {:
            RESULT = String.join(" ", f1, op, f2);
            System.out.println("REGLA 9.1: factor OP_COMPARACION factor (" + RESULT + ") -> expresion_logica_basica");
        :} |
        factor:f1 {:
            RESULT = f1;
            System.out.println("REGLA 9.2: factor (" + RESULT + ") -> expresion_logica_basica");
        :} |
        PAR_ABRE:pa expresion_logica_or:expr_or PAR_CIERRA:pc {:
            RESULT = String.join(" ", pa, expr_or, pc);
            System.out.println("REGLA 9.3: PAR_ABRE expresion_logica_or PAR_CIERRA (" + RESULT + ") -> expresion_logica_basica");
        :};

// FIXME: modificar precedencia mediante paréntesis
// FIXME: revisar precedencia, me parece que hace primero lo de la derecha? (ej: 10 - 5 + 20 = -15)
op_aritmetica_suma_resta ::=
        factor:f1 OP_ARIT_SUMA_O_RESTA:tipo_op op_aritmetica_suma_resta:terminos_restantes {:
            RESULT = String.join(" ", f1, tipo_op, terminos_restantes);
            System.out.println("REGLA 20.1: factor " + tipo_op + " op_aritmetica_suma_resta (" + RESULT + ") -> op_aritmetica_suma_resta");
        :} |
        factor:f1 OP_ARIT_SUMA_O_RESTA:tipo_op factor:f2 {:
            RESULT = String.join(" ", f1, tipo_op, f2);
            System.out.println("REGLA 20.2: factor " + tipo_op + " factor (" + RESULT + ") -> op_aritmetica_suma_resta");
        :} |
        op_aritmetica_producto_division:terminos_restantes {:
            RESULT = terminos_restantes;
            System.out.println("REGLA 20.3: op_aritmetica_producto_division (" + RESULT + ") -> op_aritmetica_suma_resta");
        :};

op_aritmetica_producto_division ::=
        factor:f1 OP_ARIT_PROD_O_DIV:tipo_op op_aritmetica_producto_division:terminos_restantes {:
            RESULT = String.join(" ", f1, tipo_op, terminos_restantes);
            System.out.println("REGLA 21.1: factor " + tipo_op + " op_aritmetica_producto_division (" + RESULT + ") -> op_aritmetica_producto_division");
        :} |
        factor:f1 OP_ARIT_PROD_O_DIV:tipo_op factor:f2 {:
            RESULT = String.join(" ", f1, tipo_op, f2);
            System.out.println("REGLA 21.2: op_aritmetica_producto_division -> factor " + tipo_op + " factor (" + RESULT + ") -> op_aritmetica_producto_division");
        :};

factor ::=
        numero_constante:num {:
            RESULT = num;
            System.out.println("REGLA 11.1: numero_constante (" + RESULT + ") -> factor");
        :} |
        IDENTIFICADOR:id {:
            RESULT = id;
            System.out.println("REGLA 11.2: IDENTIFICADOR (" + RESULT + ") -> factor");
        :} |
        CTE_BOOLEANA:cte {:
            RESULT = cte;
            System.out.println("REGLA 11.3: CTE_BOOLEANA (" + RESULT + ") -> factor");
        :} |
        CADENA:c {:
            RESULT = c;
            System.out.println("REGLA 11.4: CADENA (" + RESULT + ") -> factor");
        :} |
        invocacion_funcion:fun {:
            RESULT = fun;
            System.out.println("REGLA 11.5: invocacion_funcion (" + RESULT + ") -> factor");
        :};
        // TODO parentesis
        //PAR_ABRE:pa operacion:op PAR_CIERRA:pc {:
        //    RESULT = String.join(" ", pa, op, pc);
        //    System.out.println("REGLA 11.6: PA_ABRE operacion PA_CIERRA (" + RESULT + ") -> factor");
        //:};

lst_args ::=
        factor:f PR_COMA:pr_coma lst_args:args {:
            RESULT = String.join(" ", f, pr_coma, args);
            System.out.println("REGLA 12.1: factor lst (" + RESULT + ") -> lst_args");
        :} |
        factor:f {:
            RESULT = f;
            System.out.println("REGLA 12.2: factor (" + RESULT + ") -> lst_args");
        :};

numero_constante ::=
        ENTERO:num {:
            RESULT = num;
            System.out.println("REGLA 11.1.1: ENTERO (" + RESULT + ") -> numero_constante");
        :} |
        FLOTANTE:num {:
            RESULT = num;
            System.out.println("REGLA 11.1.2: FLOTANTE (" + RESULT + ") -> numero_constante");
        :};

invocacion_funcion ::=
        PR_WRITELN:writeln PAR_ABRE:pa operacion:op PAR_CIERRA:pc {:
            RESULT = String.join(" ", writeln, pa, op, pc);
            System.out.println("REGLA 13.1: PR_WRITELN PAR_ABRE operacion PAR_CIERRA (" + RESULT + ") -> invocacion_funcion");
        :} |
        PR_WRITE:write PAR_ABRE:pa operacion:op PAR_CIERRA:pc {:
            RESULT = String.join(" ", write, pa, op, pc);
            System.out.println("REGLA 13.2: PR_WRITE PAR_ABRE operacion PAR_CIERRA (" + RESULT + ") -> invocacion_funcion");
        :} |
        PR_READ_INTEGER:read_integer PAR_ABRE:pa PAR_CIERRA:pc {:
            RESULT = String.join(read_integer, pa, pc);
            System.out.println("REGLA 13.3: PR_READ_INTEGER PAR_ABRE PAR_CIERRA (" + RESULT + ") -> invocacion_funcion");
        :} |
        PR_READ_FLOAT:read_float PAR_ABRE:pa PAR_CIERRA:pc {:
            RESULT = String.join(read_float, pa, pc);
            System.out.println("REGLA 13.4: PR_READ_FLOAT PAR_ABRE PAR_CIERRA (" + RESULT + ") -> invocacion_funcion");
        :} |
        PR_READ_BOOLEAN:read_boolean PAR_ABRE:pa PAR_CIERRA:pc {:
            RESULT = String.join(read_boolean, pa, pc);
            System.out.println("REGLA 13.5: PR_READ_BOOLEAN PAR_ABRE PAR_CIERRA (" + RESULT + ") -> invocacion_funcion");
        :} |
        IDENTIFICADOR:id PAR_ABRE:pa PAR_CIERRA:pc {:
            RESULT = String.join(" ", id, pa, pc);
            System.out.println("REGLA 13.6: IDENTIFICADOR PAR_ABRE PAR_CIERRA (" + RESULT + ") -> invocacion_funcion");
        :} |
        IDENTIFICADOR:id PAR_ABRE:pa lst_args:args PAR_CIERRA:pc {:
            RESULT = String.join(" ", id, pa, args, pc);
            System.out.println("REGLA 13.7: IDENTIFICADOR PAR_ABRE lst_terminos PAR_CIERRA (" + RESULT + ") -> invocacion_funcion");
        :};
