package ar.edu.unnoba.compilador;

import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.List;
import java.io.FileReader;
import java.util.logging.Level;
import java.util.logging.Logger;

class MiParser;

parser code
{:
    public void syntax_error(Symbol s){
        System.out.println("Error en la linea "+ (s.left+1)+ " Columna "+ s.right+ ". Valor simbolo '"
        +s.value+"' . Simbolo n° "+s.sym+ " no reconocido." );
    }

    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{
        System.out.println("Error en la linea "+ (s.left+1)+ " Columna "+ s.right+ ". Valor simbolo '"
        +s.value+"' . Simbolo n° "+s.sym+ " no reconocido." );
    }

:};

terminal String IDENTIFICADOR,
    OP_ARIT_SUMA_O_RESTA, OP_ARIT_PROD_O_DIV, OP_COMPARACION,
    OP_LOG_BIN_OR, OP_LOG_BIN_AND, OP_LOG_UNA_NOT,
    PAR_ABRE, PAR_CIERRA, PR_IF, PR_THEN, PR_ELSE, PUNTO_Y_COMA, IGUAL,
    PR_MAIN_IS, PR_END_PUNTO, PR_VARIABLE, PR_IS,
    PR_FUNCTION, PR_RETURN, PR_COMA,
    PR_BEGIN, PR_END,
    TIPO_DE_DATO, CTE_BOOLEANA, ENTERO, FLOTANTE;

nonterminal String programa, cuerpo,
    lst_decs_vars_y_funcs, dec_var, dec_fun, lst_args, arg,
    estructura_condicional_if,
    sentencia, asignacion, expresion, comparacion, termino,
    expresion_logica_or, expresion_logica_and,
    op_aritmetica_suma_resta, op_aritmetica_producto_division,
    numero_constante;

// Precedencia de operadores. Ni idea si está bien así, todavía no lo puedo probar
// FIXME: operador unario "-", ¿cómo diferenciarlo de la resta?
precedence left OP_LOG_BIN_OR, OP_ARIT_SUMA_O_RESTA;
precedence left OP_LOG_BIN_AND, OP_ARIT_PROD_O_DIV;
precedence left OP_LOG_UNA_NOT;

start with lst_decs_vars_y_funcs;

programa ::= lst_decs_vars_y_funcs:lst PR_MAIN_IS:is cuerpo:cuerpo PR_END_PUNTO:end {:
        RESULT = String.join(" ", lst, is, cuerpo, end);
        System.out.println("REGLA 0 -> lst_decs_vars_y_funcs PR_MAIN_IS cuerpo PR_END_PUNTO (" + RESULT + ") -> programa");
    :};

lst_decs_vars_y_funcs ::=
        dec_var:dec_var lst_decs_vars_y_funcs:lst {:
             RESULT = String.join(" ", dec_var, lst);
             System.out.println("REGLA 1.3: dec_var (" + RESULT + ") -> lst_decs_vars_y_funcs");
        :} |
        dec_fun:dec_fun lst_decs_vars_y_funcs:lst {:
            RESULT = String.join(" ", dec_fun, lst);
            System.out.println("REGLA 1.3: dec_fun (" + RESULT + ") -> lst_decs_vars_y_funcs");
        :} |
        dec_var:dec_var {:
            RESULT = dec_var;
            System.out.println("REGLA 1.3: dec_var (" + RESULT + ") -> lst_decs_vars_y_funcs");
        :} |
        dec_fun:dec_fun {:
            RESULT = dec_fun;
            System.out.println("REGLA 1.4: dec_fun (" + RESULT + ") -> lst_decs_vars_y_funcs");
        :};

// TODO: En el caso de tratarse de una variable global, dicha expresión no deberá admitir
// invocaciones a funciones como parte de la expresión (no ocurriendo lo mismo con
// variables locales a un bloque de sentencias o función, donde dicha restricción no existe).
dec_var ::=
        PR_VARIABLE:pr_var arg:arg PUNTO_Y_COMA:pyc {:
             RESULT = String.join(" ", pr_var, arg, pyc);
             System.out.println("REGLA 2: PR_VARIABLE arg PUNTO_Y_COMA (" + RESULT + ") -> dec_var");
        :};

dec_fun ::=
        PR_FUNCTION IDENTIFICADOR PAR_ABRE PAR_CIERRA PR_RETURN TIPO_DE_DATO {: :} |
        PR_FUNCTION IDENTIFICADOR PAR_ABRE lst_args PAR_CIERRA PR_RETURN TIPO_DE_DATO {: :};

lst_args ::=
        arg PR_COMA lst_args {: :} |
        arg {: :};

arg ::=
        IDENTIFICADOR:id PR_IS:is TIPO_DE_DATO:td  {:
            RESULT = String.join(" ", id, is, td);
            System.out.println("REGLA 5.1: IDENTIFICADOR PR_IS TIPO_DE_DATO (" + RESULT + ") -> arg");
        :} |
        IDENTIFICADOR:id PR_IS:is TIPO_DE_DATO:td IGUAL:igual termino:t {:
            RESULT = String.join(" ", id, is, td, igual, t);
            System.out.println("REGLA 5.2: IDENTIFICADOR PR_IS TIPO_DE_DATO (" + RESULT + ") -> arg");
        :};

// TODO: agregar funciones, por ej. writeln("..."), al cuerpo
// TODO: agregar las estructuras de control e iteración que definamos al cuerpo
cuerpo ::= estructura_condicional_if;

estructura_condicional_if ::=
        PR_IF expresion_logica_or PR_THEN sentencia PUNTO_Y_COMA {: :} |
        PR_IF expresion_logica_or PR_THEN sentencia PR_ELSE sentencia PUNTO_Y_COMA {: :};

// FIXME: agregar llamadas a funciones, estructuras de control y lo que haga falta
sentencia ::= asignacion;
asignacion ::= IDENTIFICADOR IGUAL termino;

expresion ::=
        expresion_logica_or {: :} |
        op_aritmetica_suma_resta {: :};

expresion_logica_or ::=
        comparacion OP_LOG_BIN_OR expresion_logica_or {:
        :} |
        comparacion {:
        :}
        expresion_logica_and {:
        :} |;

expresion_logica_and ::=
        comparacion OP_LOG_BIN_AND expresion_logica_and {:
        :} |
        comparacion {:
        :};

comparacion ::= termino OP_COMPARACION termino;

// FIXME: modificar precedencia mediante paréntesis
op_aritmetica_suma_resta ::=
        termino:t1 OP_ARIT_SUMA_O_RESTA:tipo_op op_aritmetica_suma_resta:terminos_restantes {:
            RESULT = String.join(" ", t1, tipo_op, terminos_restantes);
            System.out.println("REGLA 10.1: termino " + tipo_op + " op_aritmetica_suma_resta (" + RESULT + ") -> op_aritmetica_suma_resta");
        :} |
        termino:t1 OP_ARIT_SUMA_O_RESTA:tipo_op termino:t2 {:
            RESULT = String.join(" ", t1, tipo_op, t2);
            System.out.println("REGLA 10.2: termino " + tipo_op + " termino (" + RESULT + ") -> op_aritmetica_suma_resta");
        :} |
        op_aritmetica_producto_division:terminos_restantes {:
            RESULT = terminos_restantes;
            System.out.println("REGLA 10.3: op_aritmetica_producto_division (" + RESULT + ") -> op_aritmetica_suma_resta");
        :};

op_aritmetica_producto_division ::=
        termino:t1 OP_ARIT_PROD_O_DIV:tipo_op op_aritmetica_producto_division:terminos_restantes {:
            RESULT = String.join(" ", t1, tipo_op, terminos_restantes);
            System.out.println("REGLA 11.1: termino " + tipo_op + " op_aritmetica_producto_division (" + RESULT + ") -> op_aritmetica_producto_division");
        :} |
        termino:t1 OP_ARIT_PROD_O_DIV:tipo_op termino:t2 {:
            RESULT = String.join(" ", t1, tipo_op, t2);
            System.out.println("REGLA 11.2: op_aritmetica_producto_division -> termino " + tipo_op + " termino (" + RESULT + ") -> op_aritmetica_producto_division");
        :};

// FIXME: el término tmb. puede ser una función que devuelvan un valor
termino ::=
        numero_constante:num {:
            RESULT = num;
            System.out.println("REGLA 8.1: numero_constante (" + RESULT + ") -> termino");
        :} |
        IDENTIFICADOR:id {:
            RESULT = id;
            System.out.println("REGLA 8.2: IDENTIFICADOR (" + RESULT + ") -> termino");
        :} |
        CTE_BOOLEANA:cte {:
            RESULT = cte;
            System.out.println("REGLA 8.3: CTE_BOOLEANA (" + RESULT + ") -> termino");
        :};

numero_constante ::=
        ENTERO:num {:
            RESULT = num;
            System.out.println("REGLA 8.1.1: ENTERO (" + RESULT + ") -> numero_constante");
        :} |
        FLOTANTE:num {:
            RESULT = num;
            System.out.println("REGLA 8.1.2: FLOTANTE (" + RESULT + ") -> numero_constante");
        :};