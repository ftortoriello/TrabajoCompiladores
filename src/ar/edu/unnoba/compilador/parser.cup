package ar.edu.unnoba.compilador;

import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.List;
import java.io.FileReader;
import java.util.logging.Level;
import java.util.logging.Logger;

class MiParser;

parser code
{:
    public void syntax_error(Symbol s){
        System.out.println("Error en la linea "+ (s.left+1)+ " Columna "+ s.right+ ". Valor simbolo '"
        +s.value+"' . Simbolo n° "+s.sym+ " no reconocido." );
    }

    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{
        System.out.println("Error en la linea "+ (s.left+1)+ " Columna "+ s.right+ ". Valor simbolo '"
        +s.value+"' . Simbolo n° "+s.sym+ " no reconocido." );
    }

:};


// Definiciones que estaban en el ejemplo original (borrar en próximos commits):
// terminal MAS, MENOS, MULT, DIV, PAR_ABRE, PAR_CIERRA, MENOS_UNARIO;
// terminal String IDENTIFICADOR, ENTERO;
// nonterminal String expression, expr;

// precedence left MAS, MENOS;
// precedence left MULT, DIV;
// precedence left MENOS_UNARIO;

// start with expression;

// Operadores aritméticos
terminal String OP_ARIT_SUMA, OP_ARIT_RESTA, OP_ARIT_PROD, OP_ARIT_DIV;

// Operadores condicionales
terminal String OP_COND_IGUALDAD, OP_COND_MAYOR, OP_COND_MAYOR_IGUAL, OP_COND_MENOR, OP_COND_MENOR_IGUAL;

// Operadores lógicos
terminal String OP_LOG_BIN_OR, OP_LOG_BIN_AND, OP_LOG_UNA_NOT;

// Palabras reservadas y otros
terminal String PAR_ABRE, PAR_CIERRA, PR_IF, PR_THEN, PR_ELSE, PUNTO_Y_COMA;

// Constantes booleanas
terminal String VALOR_BOOLEANO_TRUE, VALOR_BOOLEANO_FALSE;

// Tipos de datos
terminal String TDD_BOOLEAN, TDD_INTEGER, TDD_FLOAT;

// Variables no terminales
nonterminal ESTRUCT_COND_IF, CONDICION, SENTENCIA;


// Precedencia de operadores. Ni idea si está bien así, no lo puedo probar
// FIXME: operador unario "-", ¿cómo diferenciarlo de la resta?
precedence left OP_LOG_BIN_OR, OP_ARIT_SUMA, OP_ARIT_RESTA;
precedence left OP_LOG_BIN_AND, OP_ARIT_PROD, OP_ARIT_DIV;
precedence left OP_LOG_UNA_NOT;

// Lo pongo así para que compile, cambiar por expresión o similar más adelante
start with ESTRUCT_COND_IF;

ESTRUCT_COND_IF::=  PR_IF CONDICION PR_THEN SENTENCIA PUNTO_Y_COMA
                    | PR_IF CONDICION PR_THEN SENTENCIA PR_ELSE SENTENCIA PUNTO_Y_COMA;

// TODO:
CONDICION::= ;
SENTENCIA::= ;



// Reglas semánticas del ejemplo viejo, las dejo para tenerlas a mano -- borrar más adelante.
//expression ::= expr:e {:
//            System.out.println("REGLA 0: expr -> expr EOF");
//            RESULT = e;
//        :};
//
//expr ::= expr:e1 MAS expr:e2 {:
//            System.out.println("REGLA 1.1: expr -> expr MAS expr");
//            RESULT = e1+"+"+e2;
//        :};
//
//expr ::= expr:e1 MENOS expr:e2 {:
//            System.out.println("REGLA 1.2: expr -> expr MENOS expr");
//            RESULT = e1+"-"+e2;
//        :};
//
//expr ::= expr:e1 MULT expr:e2 {:
//            System.out.println("REGLA 1.3: expr -> expr MULT expr");
//            RESULT = e1+"*"+e2;
//        :};
//
//expr ::= expr:e1 DIV expr:e2 {:
//            System.out.println("REGLA 1.4: expr -> expr DIV expr");
//            RESULT = e1+"*"+e2;
//        :};
//
//expr ::= PAR_ABRE expr:e PAR_CIERRA {:
//            System.out.println("REGLA 1.5: expr -> ( expr )");
//            RESULT = "("+e+")";
//        :};
//
//expr ::= IDENTIFICADOR:id {:
//            System.out.println("REGLA 1.6: expr -> IDENTIFICADOR)");
//            RESULT = id;
//        :};
//
//expr ::= ENTERO:ent {:
//            System.out.println("REGLA 1.6: expr -> ENTERO)");
//            RESULT = ent;
//        :};
//
//expr ::= MENOS expr:e{:
//            System.out.println("REGLA 1.7: expr -> MENOS expr)");
//            RESULT = "-"+e;
//        :} %prec MENOS_UNARIO;
