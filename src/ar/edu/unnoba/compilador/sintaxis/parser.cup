package ar.edu.unnoba.compilador.sintaxis;

import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.List;
import java.io.FileReader;
import java.util.logging.Level;
import java.util.logging.Logger;

import ar.edu.unnoba.compilador.token.Token;

import ar.edu.unnoba.compilador.ast.base.Nodo;
import ar.edu.unnoba.compilador.ast.base.Programa;
import ar.edu.unnoba.compilador.ast.base.Encabezado;
import ar.edu.unnoba.compilador.ast.base.Bloque;

import ar.edu.unnoba.compilador.ast.sentencias.Sentencia;

import ar.edu.unnoba.compilador.ast.sentencias.declaracion.Asignacion;
import ar.edu.unnoba.compilador.ast.sentencias.declaracion.Declaracion;
import ar.edu.unnoba.compilador.ast.sentencias.declaracion.DecFuncion;
import ar.edu.unnoba.compilador.ast.sentencias.declaracion.DecVar;
import ar.edu.unnoba.compilador.ast.sentencias.declaracion.DecVarInicializada;

import ar.edu.unnoba.compilador.ast.sentencias.seleccion.Cuando;
import ar.edu.unnoba.compilador.ast.sentencias.seleccion.CasoCuando;
import ar.edu.unnoba.compilador.ast.sentencias.seleccion.SiEntonces;
import ar.edu.unnoba.compilador.ast.sentencias.seleccion.SiEntoncesSino;

import ar.edu.unnoba.compilador.ast.sentencias.iteracion.Mientras;
import ar.edu.unnoba.compilador.ast.sentencias.iteracion.Para;

import ar.edu.unnoba.compilador.ast.sentencias.control.Control;
import ar.edu.unnoba.compilador.ast.sentencias.control.Salir;
import ar.edu.unnoba.compilador.ast.sentencias.control.Continuar;
import ar.edu.unnoba.compilador.ast.sentencias.control.Retorno;

import ar.edu.unnoba.compilador.ast.expresiones.Expresion;

import ar.edu.unnoba.compilador.ast.expresiones.binarias.logicas.Disyuncion;
import ar.edu.unnoba.compilador.ast.expresiones.binarias.logicas.Conjuncion;
import ar.edu.unnoba.compilador.ast.expresiones.unarias.logicas.NegacionLogica;

import ar.edu.unnoba.compilador.ast.expresiones.binarias.relaciones.Desigualdad;
import ar.edu.unnoba.compilador.ast.expresiones.binarias.relaciones.Igualdad;
import ar.edu.unnoba.compilador.ast.expresiones.binarias.relaciones.Mayor;
import ar.edu.unnoba.compilador.ast.expresiones.binarias.relaciones.MayorIgual;
import ar.edu.unnoba.compilador.ast.expresiones.binarias.relaciones.Menor;
import ar.edu.unnoba.compilador.ast.expresiones.binarias.relaciones.MenorIgual;

import ar.edu.unnoba.compilador.ast.expresiones.binarias.OperacionBinaria;
import ar.edu.unnoba.compilador.ast.expresiones.binarias.aritmeticas.Adicion;
import ar.edu.unnoba.compilador.ast.expresiones.binarias.aritmeticas.Suma;
import ar.edu.unnoba.compilador.ast.expresiones.binarias.aritmeticas.Resta;
import ar.edu.unnoba.compilador.ast.expresiones.binarias.aritmeticas.Multiplicacion;
import ar.edu.unnoba.compilador.ast.expresiones.binarias.aritmeticas.Division;
import ar.edu.unnoba.compilador.ast.expresiones.unarias.aritmeticas.NegacionAritmetica;

import ar.edu.unnoba.compilador.ast.expresiones.Tipo;
import ar.edu.unnoba.compilador.ast.expresiones.OperadorCmp;
import ar.edu.unnoba.compilador.ast.expresiones.valor.Identificador;
import ar.edu.unnoba.compilador.ast.expresiones.valor.Constante;
import ar.edu.unnoba.compilador.ast.expresiones.valor.InvocacionFuncion;

class Parser;

parser code
{:
    public void syntax_error(Symbol s) {
        System.out.println("Error en la línea "+ (s.left+1) + " Columna "+ s.right + ". Símbolo '"
        + s.value + "'. Símbolo n° " + s.sym + " no reconocido.");
    }

    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception {
        System.out.println("Error en la línea "+ (s.left+1) + " Columna " + s.right + ". Símbolo '"
        + s.value + "'. Símbolo n° " + s.sym + " no reconocido." );
    }

    public void imprimirEtiqueta(Nodo nodo) {
        System.out.println("Se creó el nodo " + nodo.getEtiqueta());
    }

    public OperacionBinaria getClaseRel(OperadorCmp op, Expresion expr1, Expresion expr2) {
        // Crea una clase según sea el operador utilizado
        // Si se utiliza el operador de IGUALDAD, devuelvo una clase Igualdad, etc.
        OperacionBinaria comp;

        switch (op) {
            case IGUALDAD:
                comp = new Igualdad(expr1, expr2);
                break;
            case DESIGUALDAD:
                comp = new Desigualdad(expr1, expr2);
                break;
            case MAYOR:
                comp = new Mayor(expr1, expr2);
                break;
            case MAYOR_IGUAL:
                comp = new MayorIgual(expr1, expr2);
                break;
            case MENOR:
                comp = new Menor(expr1, expr2);
                break;
            default:
                comp = new MenorIgual(expr1, expr2);
                break;
        }

        return comp;
    }

    public Tipo getTipoDato(String tipoStr) {
        // Recibe el lexema TIPO (en forma de cadena) y devuelve el enum Tipo correspondiente
        Tipo tipo;

        switch (tipoStr.toUpperCase()) {
            case "BOOL":
                tipo = Tipo.BOOL;
                break;
            case "INTEGER":
                tipo = Tipo.INTEGER;
                break;
            case "FLOAT":
                tipo = Tipo.FLOAT;
                break;
            default:
                tipo = Tipo.UNKNOWN;
                break;
        }

        return tipo;
    }

    public OperadorCmp getTipoOpCmp(String opStr) {
        // Recibe el lexema OP_COMPARACION (en forma de cadena) y devuelve el enum OperadorCmp correspondiente
        OperadorCmp op;

        switch (opStr) {
            case "==":
                op = OperadorCmp.IGUALDAD;
                break;
            case "!=":
                op = OperadorCmp.DESIGUALDAD;
                break;
            case ">":
                op = OperadorCmp.MAYOR;
                break;
            case ">=":
                op = OperadorCmp.MAYOR_IGUAL;
                break;
            case "<":
                op = OperadorCmp.MENOR;
                break;
            default:
                op = OperadorCmp.MENOR_IGUAL;
                break;
        }

        return op;

    }

:};

terminal String PR_MAIN_IS, PR_END_PUNTO,
    PR_VARIABLE, PR_IS, PR_FUNCTION, PR_RETURN,
    PR_BEGIN, PR_END,
    PR_IF, PR_THEN, PR_ELSE, PR_WHEN, PR_WHILE,
    PR_FOR, PR_FROM, PR_TO, PR_BY, PR_DO, PR_BREAK, PR_CONTINUE,
    PR_WRITELN, PR_WRITE, PR_READ_INTEGER, PR_READ_FLOAT, PR_READ_BOOLEAN,
    OP_LOG_BIN_OR, OP_LOG_BIN_AND, OP_LOG_UNA_NOT,
    OP_COMPARACION,
    OP_ARIT_SUMA, OP_ARIT_RESTA, OP_ARIT_PROD, OP_ARIT_DIV,
    PAR_ABRE, PAR_CIERRA, PR_COMA, PUNTO_Y_COMA, IGUAL,
    IDENTIFICADOR, TIPO_DE_DATO,
    CTE_BOOLEANA, FLOTANTE, ENTERO, CADENA;

nonterminal Programa programa;
nonterminal List<Declaracion> encabezado;
nonterminal Bloque cuerpo_programa, bloque;
nonterminal List<CasoCuando> bloque_cuando;

// Las producciones "sentencia" podrían ser de tipo Sentencia, pero para poder incluir
// a invocacion_funcion, que es de tipo Expresión, tengo que declararlas como Nodo...
// TODO: ver si puede reestructurarse para que quede más prolijo.
nonterminal List<Nodo> lst_sentencias;
nonterminal Nodo sentencia;

nonterminal Expresion expresion, conjuncion, negacion_logica,
    relacion, adicion, termino, negacion_aritmetica,
    factor, constante, invocacion_funcion;

nonterminal List<Expresion> lista_exprs;

nonterminal Sentencia asignacion, si_entonces, cuando, para, mientras, control;
nonterminal DecFuncion dec_fun;

nonterminal List<DecVar> lst_args_dec, lst_args_dec_default;
nonterminal DecVar dec_var, arg_dec, arg_dec_default;

// Antes no hacían falta las precedencias de IDENTIFICADOR y OP_ARIT_RESTA, con los cambios que hice en el Parser sí
// TODO: ¿ver de eliminar ambigüedad?
precedence left PR_ELSE, PR_IS;
precedence right IDENTIFICADOR, OP_ARIT_RESTA, PR_VARIABLE, PR_FUNCTION;

start with programa;

programa ::=
        encabezado:decs cuerpo_programa:cpo_prog {:
            Encabezado enc = new Encabezado(decs);
            Programa prog = new Programa("Programa", enc, cpo_prog);
            imprimirEtiqueta(prog);
            RESULT = prog;
        :};

cuerpo_programa ::=
        PR_MAIN_IS:pr_main_is lst_sentencias:sentencias PR_END_PUNTO:pr_end {:
            boolean esBloquePrincipal = true;
            Bloque cuerpoPrograma = new Bloque("Bloque principal", sentencias, esBloquePrincipal);
            imprimirEtiqueta(cuerpoPrograma);
            RESULT = cuerpoPrograma;
        :} |
        PR_MAIN_IS:pr_main_is PR_END_PUNTO:pr_end {:
            boolean esBloquePrincipal = true;
            Bloque cuerpoPrograma = new Bloque("Bloque principal (vacío)", esBloquePrincipal);
            imprimirEtiqueta(cuerpoPrograma);
            RESULT = cuerpoPrograma;
        :};

encabezado ::=
        encabezado:decs dec_var:dec_var PUNTO_Y_COMA:pyc{:
            decs.add(dec_var);
            imprimirEtiqueta(dec_var);
            RESULT = decs;
        :} |
        encabezado:decs dec_fun:dec_fun {:
            decs.add(dec_fun);
            imprimirEtiqueta(dec_fun);
            RESULT = decs;
        :} |
        dec_var:dec_var PUNTO_Y_COMA:pyc {:
            List<Declaracion> decs = new ArrayList<Declaracion>();
            decs.add(dec_var);
            imprimirEtiqueta(dec_var);
            RESULT = decs;
        :} |
        dec_fun:dec_fun {:
            List<Declaracion> decs = new ArrayList<Declaracion>();
            decs.add(dec_fun);
            imprimirEtiqueta(dec_fun);
            RESULT = decs;
        :} |
        {:
            // Encabezado vacío
            RESULT = new ArrayList<Declaracion>();
        :};

dec_var ::=
        PR_VARIABLE:pr_var arg_dec:arg_dec {:
            RESULT = arg_dec;
        :} |
        PR_VARIABLE:pr_var arg_dec_default:arg_dec_default {:
            RESULT = arg_dec_default;
        :};

arg_dec ::=
        IDENTIFICADOR:id PR_IS:pr_is TIPO_DE_DATO:td {:
            Identificador ident = new Identificador(id, getTipoDato(td));
            DecVar decVar = new DecVar("Variable sin inicializar", ident);
            imprimirEtiqueta(decVar);
            RESULT = decVar;
        :};

arg_dec_default ::=
        IDENTIFICADOR:id PR_IS:pr_is TIPO_DE_DATO:td IGUAL:igual expresion:expr {:
            Identificador ident = new Identificador(id, getTipoDato(td));
            DecVarInicializada decVar = new DecVarInicializada("Variable inicializada", ident, expr);
            imprimirEtiqueta(decVar);
            RESULT = decVar;
        :};

dec_fun ::=
        PR_FUNCTION:pr_funcion IDENTIFICADOR:id PAR_ABRE:pa PAR_CIERRA:pc PR_RETURN:ret TIPO_DE_DATO:td bloque:bloque PUNTO_Y_COMA:pyc {:
            Identificador ident = new Identificador(id, getTipoDato(td));
            DecFuncion decFun = new DecFuncion(ident, bloque);
            imprimirEtiqueta(decFun);
            RESULT = decFun;
        :} |
        PR_FUNCTION:pr_funcion IDENTIFICADOR:id PAR_ABRE:pa lst_args_dec:args PAR_CIERRA:pc PR_RETURN:ret TIPO_DE_DATO:td bloque:bloque PUNTO_Y_COMA:pyc {:
            Identificador ident = new Identificador(id, getTipoDato(td));
            DecFuncion decFun = new DecFuncion(ident, args, bloque);
            imprimirEtiqueta(decFun);
            RESULT = decFun;
        :};

lst_args_dec ::=
        // TODO: creo que rompí lo de los valores por defecto
        arg_dec:arg PR_COMA:pr_coma lst_args_dec:args {:
            args.add(arg);
            imprimirEtiqueta(arg);
            RESULT = args;
        :} |
        arg_dec:arg {:
            List<DecVar> args = new ArrayList<DecVar>();
            args.add(arg);
            imprimirEtiqueta(arg);
            RESULT = args;
        :} |
        arg_dec_default:arg PR_COMA:pr_coma lst_args_dec_default:args {:
            args.add(arg);
            imprimirEtiqueta(arg);
            RESULT = args;
        :} |
        arg_dec_default:arg {:
            List<DecVar> args = new ArrayList<DecVar>();
            args.add(arg);
            imprimirEtiqueta(arg);
            RESULT = args;
        :};

lst_args_dec_default ::=
        arg_dec_default:arg PR_COMA:pr_coma lst_args_dec_default:args {:
            args.add(arg);
            imprimirEtiqueta(arg);
            RESULT = args;
        :} |
        arg_dec_default:arg {:
            List<DecVar> args = new ArrayList<DecVar>();
            args.add(arg);
            imprimirEtiqueta(arg);
            RESULT = args;
        :};

bloque ::=
        sentencia:sent {:
            List<Nodo> sentencias = new ArrayList<Nodo>();
            sentencias.add(sent);
            boolean esBloquePrincipal = false;
            Bloque bloque = new Bloque("Bloque simple (una sentencia)", sentencias, esBloquePrincipal);
            RESULT = bloque;
        :} |
        PR_BEGIN:begin lst_sentencias:sentencias PR_END:pr_end {:
            boolean esBloquePrincipal = false;
            Bloque bloque = new Bloque("Bloque compuesto (múltiples sentencias)", sentencias, esBloquePrincipal);
            RESULT = bloque;
        :};

lst_sentencias ::=
        lst_sentencias:sentencias sentencia:sent PUNTO_Y_COMA:pyc {:
            sentencias.add(sent);
            RESULT = sentencias;
        :} |
        sentencia:sent PUNTO_Y_COMA:pyc {:
            List<Nodo> sentencias = new ArrayList<Nodo>();
            sentencias.add(sent);
            RESULT = sentencias;
        :};

sentencia ::=
        asignacion:asig {:
            RESULT = asig;
        :} |
        // TODO: La invocación es de tipo Expresión, y el resto de lo que está acá son Sentencia, ¿acomodar?
        invocacion_funcion:invo_fun {:
            RESULT = invo_fun;
        :} |
        dec_var:dec_var {:
            RESULT = dec_var;
        :} |
        si_entonces:si {:
            RESULT = si;
        :} |
        cuando:cuando {:
            RESULT = cuando;
        :} |
        para:para {:
            RESULT = para;
        :} |
        mientras:mientras {:
            RESULT = mientras;
        :} |
        control:ctrl {:
            RESULT = ctrl;
        :};

asignacion ::=
        IDENTIFICADOR:id IGUAL:igual expresion:expr {:
            Identificador ident = new Identificador(id);
            Asignacion asig = new Asignacion(ident, expr);
            imprimirEtiqueta(asig);
            RESULT = asig;
       :};

si_entonces ::=
        PR_IF:pr_if expresion:expr PR_THEN:pr_then bloque:bloque {:
            SiEntonces se = new SiEntonces(expr, bloque);
            imprimirEtiqueta(se);
            RESULT = se;
        :} |
        PR_IF:pr_if expresion:expr PR_THEN:pr_then bloque:bloque1 PR_ELSE:pr_else bloque:bloque2 {:
            SiEntoncesSino se = new SiEntoncesSino(expr, bloque1, bloque2);
            imprimirEtiqueta(se);
            RESULT = se;
        :};

cuando ::=
        PR_WHEN:when expresion:expr bloque_cuando:bloque_cuando {:
            Cuando cuando = new Cuando(expr, bloque_cuando);
            imprimirEtiqueta(cuando);
            RESULT = cuando;
        :} |
        PR_WHEN:when expresion:expr bloque_cuando:bloque_cuando PR_ELSE:pr_else bloque:bloque {:
            Cuando cuando = new Cuando(expr, bloque_cuando);
            imprimirEtiqueta(cuando);
            RESULT = cuando;
        :};

bloque_cuando ::=
        PR_IS:pr_is OP_COMPARACION:op expresion:expr PR_THEN:pr_then bloque:bloque {:
            List<CasoCuando> bloqueCuando = new ArrayList<CasoCuando>();
            CasoCuando caso = new CasoCuando(getTipoOpCmp(op), expr, bloque);
            imprimirEtiqueta(caso);
            bloqueCuando.add(caso);
            RESULT = bloqueCuando;
        :} |
        PR_IS:pr_is OP_COMPARACION:op expresion:expr PR_THEN:pr_then bloque:bloque bloque_cuando:bloqueCuando {:
            CasoCuando caso = new CasoCuando(getTipoOpCmp(op), expr, bloque);
            imprimirEtiqueta(caso);
            bloqueCuando.add(caso);
            RESULT = bloqueCuando;
        :};

para ::=
        PR_FOR:pr_for IDENTIFICADOR:id PR_FROM:pr_from ENTERO:num_ini PR_TO:pr_to ENTERO:num_fin PR_DO:pr_do bloque:bloque {:
            // TODO: El identificador utilizado en el FOR ya tendría que haber sido definido (y además ser Entero)
            // ¿De dónde lo saco si lo único que tengo acá es el lexema?
            int saltoPorDefecto = 1;
            Identificador ident = new Identificador(id);
            Para para = new Para("Bloque FOR con salto sin definir", ident, Integer.parseInt(num_ini),
                                Integer.parseInt(num_fin), saltoPorDefecto, bloque);
            imprimirEtiqueta(para);
            RESULT = para;
        :} |
        PR_FOR:pr_for IDENTIFICADOR:id PR_FROM:pr_from ENTERO:num_ini PR_TO:pr_to ENTERO:num_fin PR_BY:pr_by ENTERO:salto PR_DO:pr_do bloque:bloque {:
            Identificador ident = new Identificador(id);
            Para para = new Para("Bloque FOR con salto definido", ident, Integer.parseInt(num_ini),
                                Integer.parseInt(num_fin), Integer.parseInt(salto), bloque);
            imprimirEtiqueta(para);
            RESULT = para;
        :};

mientras ::=
        PR_WHILE:pr_while expresion:expr PR_DO:pr_do bloque:bloque {:
            Mientras mientras = new Mientras(expr, bloque);
            imprimirEtiqueta(mientras);
            RESULT = mientras;
        :};

control ::=
        PR_RETURN:pr_ret expresion:expr {:
            Retorno ret = new Retorno(expr);
            imprimirEtiqueta(ret);
            RESULT = ret;
        :} |
        PR_BREAK:pr_break {:
            Salir brk = new Salir();
            imprimirEtiqueta(brk);
            RESULT = brk;
        :} |
        PR_CONTINUE:pr_cont {:
            Continuar ctn = new Continuar();
            imprimirEtiqueta(ctn);
            RESULT = ctn;
        :};

expresion ::=
        expresion:expr OP_LOG_BIN_OR:op_or conjuncion:con {:
            Disyuncion dis = new Disyuncion(expr, con);
            imprimirEtiqueta(dis);
            RESULT = dis;
        :} |
        conjuncion:con {:
            RESULT = con;
        :};

conjuncion ::=
       conjuncion:con OP_LOG_BIN_AND:op_and negacion_logica:neg_log {:
            Conjuncion conjun = new Conjuncion(con, neg_log);
            imprimirEtiqueta(conjun);
            RESULT = conjun;
       :} |
       negacion_logica:neg_log {:
            RESULT = neg_log;
       :};

negacion_logica ::=
        OP_LOG_UNA_NOT:op_not relacion:rel {:
            NegacionLogica negLog = new NegacionLogica(rel);
            imprimirEtiqueta(negLog);
            RESULT = negLog;
        :} |
        relacion:relacion {:
            RESULT = relacion;
        :};

relacion ::=
        adicion:adicion1 OP_COMPARACION:op adicion:adicion2 {:
            OperacionBinaria rel = getClaseRel(getTipoOpCmp(op), adicion1, adicion2);
            imprimirEtiqueta(rel);
            RESULT = rel;
        :} |
        adicion:adicion {:
            RESULT = adicion;
        :};

adicion ::=
        adicion:adicion OP_ARIT_SUMA:op_suma termino:termino {:
            Suma suma = new Suma(adicion, termino);
            imprimirEtiqueta(suma);
            RESULT = suma;
        :} |
        adicion:adicion OP_ARIT_RESTA:op_resta termino:termino {:
            Resta resta = new Resta(adicion, termino);
            imprimirEtiqueta(resta);
            RESULT = resta;
        :} |
        termino:termino {:
            RESULT = termino;
        :};

termino ::=
        termino:termino OP_ARIT_PROD:op_prod negacion_aritmetica:negacion_aritmetica {:
            Multiplicacion multi = new Multiplicacion(termino, negacion_aritmetica);
            imprimirEtiqueta(multi);
            RESULT = multi;
        :} |
        termino:termino OP_ARIT_DIV:op_div negacion_aritmetica:negacion_aritmetica {:
            Division divi = new Division(termino, negacion_aritmetica);
            imprimirEtiqueta(divi);
            RESULT = divi;
        :} |
        negacion_aritmetica:negacion_aritmetica {:
            RESULT = negacion_aritmetica;
        :};

negacion_aritmetica ::=
        OP_ARIT_RESTA:menos factor:factor {:
            NegacionAritmetica negArit = new NegacionAritmetica(factor);
            imprimirEtiqueta(negArit);
            RESULT = negArit;
        :} |
        factor:factor {:
            RESULT = factor;
        :};

factor ::=
        constante:cte {:
            RESULT = cte;
        :} |
        IDENTIFICADOR:id {:
            Identificador ident = new Identificador(id);
            imprimirEtiqueta(ident);
            RESULT = ident;
        :} |
        invocacion_funcion:invo {:
            RESULT = invo;
        :} |
        PAR_ABRE:pa expresion:expr PAR_CIERRA:pc {:
            RESULT = expr;
        :};

constante ::=
        ENTERO:lit_int {:
            Constante cte = new Constante(lit_int, Tipo.INTEGER, "Constante INTEGER");
            imprimirEtiqueta(cte);
            RESULT = cte;
        :} |
        FLOTANTE:lit_float {:
            Constante cte = new Constante(lit_float, Tipo.FLOAT, "Constante FLOAT");
            imprimirEtiqueta(cte);
            RESULT = cte;
        :} |
        CTE_BOOLEANA:lit_bool {:
            Constante cte = new Constante(lit_bool, Tipo.BOOL, "Constante BOOL");
            imprimirEtiqueta(cte);
            RESULT = cte;
        :};

invocacion_funcion ::=
        PR_WRITELN:nombre_fun PAR_ABRE:pa expresion:expr PAR_CIERRA:pc {:
            List<Expresion> args = new ArrayList<>();
            args.add(expr);
            RESULT = new InvocacionFuncion(nombre_fun, args, Tipo.UNKNOWN);
        :} |
        PR_WRITELN:nombre_fun PAR_ABRE:pa CADENA:c PAR_CIERRA:pc {:
            List<String> args = new ArrayList<>();
            args.add("\\\"" + c + "\\\"");
            RESULT = new InvocacionFuncion(nombre_fun, args, Tipo.UNKNOWN);
        :} |
        PR_WRITE:nombre_fun PAR_ABRE:pa expresion:expr PAR_CIERRA:pc {:
            List<Expresion> args = new ArrayList<>();
            args.add(expr);
            RESULT = new InvocacionFuncion(nombre_fun, args, Tipo.UNKNOWN);
        :} |
        PR_WRITE:nombre_fun PAR_ABRE:pa CADENA:c PAR_CIERRA:pc {:
            List<String> args = new ArrayList<>();
            args.add("\\\"" + c + "\\\"");
            RESULT = new InvocacionFuncion(nombre_fun, args, Tipo.UNKNOWN);
        :} |
        PR_READ_INTEGER:nombre_fun PAR_ABRE:pa PAR_CIERRA:pc {:
            InvocacionFuncion invo = new InvocacionFuncion(nombre_fun, new ArrayList<Expresion>(), Tipo.INTEGER);
            imprimirEtiqueta(invo);
            RESULT = invo;
        :} |
        PR_READ_FLOAT:nombre_fun PAR_ABRE:pa PAR_CIERRA:pc {:
            InvocacionFuncion invo = new InvocacionFuncion(nombre_fun, new ArrayList<Expresion>(), Tipo.FLOAT);
            imprimirEtiqueta(invo);
            RESULT = invo;
        :} |
        PR_READ_BOOLEAN:nombre_fun PAR_ABRE:pa PAR_CIERRA:pc {:
            InvocacionFuncion invo = new InvocacionFuncion(nombre_fun, new ArrayList<Expresion>(), Tipo.BOOL);
            imprimirEtiqueta(invo);
            RESULT = invo;
        :} |
        IDENTIFICADOR:nombre_fun PAR_ABRE:pa lista_exprs:args PAR_CIERRA:pc {:
            InvocacionFuncion invo = new InvocacionFuncion(nombre_fun, args, Tipo.UNKNOWN);
            imprimirEtiqueta(invo);
            RESULT = invo;
        :};

// Expresiones que se pasan como parámetro a una función
lista_exprs ::=
        lista_exprs:args PR_COMA:pr_coma expresion:arg {:
            args.add(arg);
            RESULT = args;
        :} |
        expresion:arg {:
            List<Expresion> args = new ArrayList<Expresion>();
            args.add(arg);
            RESULT = args;
        :} | {:
            // Para que acepte la producción cuando no se pasa ningún argumento,
            // y a la vez genere una lista vacía para pasarle al constructor.
            List<Expresion> args = new ArrayList<>();
            RESULT = args;
        :};
