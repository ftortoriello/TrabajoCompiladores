package ar.edu.unnoba.compilador.sintaxis;

import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.List;
import java.io.FileReader;
import java.util.logging.Level;
import java.util.logging.Logger;

import ar.edu.unnoba.compilador.token.Token;

import ar.edu.unnoba.compilador.ast.base.Nodo;
import ar.edu.unnoba.compilador.ast.base.Programa;
// import ar.edu.unnoba.compilador.ast.base.Bloque;
// import ar.edu.unnoba.compilador.ast.base.Encabezado;
import ar.edu.unnoba.compilador.ast.base.Expresion;


import ar.edu.unnoba.compilador.ast.operaciones.binarias.logicas.Disyuncion;
import ar.edu.unnoba.compilador.ast.operaciones.binarias.logicas.Conjuncion;
import ar.edu.unnoba.compilador.ast.operaciones.unarias.logicas.NegacionLogica;

import ar.edu.unnoba.compilador.ast.operaciones.binarias.relaciones.Desigualdad;
import ar.edu.unnoba.compilador.ast.operaciones.binarias.relaciones.Igualdad;
import ar.edu.unnoba.compilador.ast.operaciones.binarias.relaciones.Mayor;
import ar.edu.unnoba.compilador.ast.operaciones.binarias.relaciones.MayorIgual;
import ar.edu.unnoba.compilador.ast.operaciones.binarias.relaciones.Menor;
import ar.edu.unnoba.compilador.ast.operaciones.binarias.relaciones.MenorIgual;

import ar.edu.unnoba.compilador.ast.operaciones.binarias.aritmeticas.Suma;
import ar.edu.unnoba.compilador.ast.operaciones.binarias.aritmeticas.Resta;
import ar.edu.unnoba.compilador.ast.operaciones.binarias.aritmeticas.Multiplicacion;
import ar.edu.unnoba.compilador.ast.operaciones.binarias.aritmeticas.Division;
import ar.edu.unnoba.compilador.ast.operaciones.unarias.aritmeticas.NegacionAritmetica;

import ar.edu.unnoba.compilador.ast.base.Tipo;
import ar.edu.unnoba.compilador.ast.base.Identificador;
import ar.edu.unnoba.compilador.ast.base.Constante;
import ar.edu.unnoba.compilador.ast.base.InvocacionFuncion;

class Parser;

parser code
{:
    public void syntax_error(Symbol s) {
        System.out.println("Error en la línea "+ (s.left+1) + " Columna "+ s.right + ". Símbolo '"
        + s.value + "'. Símbolo n° " + s.sym + " no reconocido.");
    }

    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception {
        System.out.println("Error en la línea "+ (s.left+1) + " Columna " + s.right + ". Símbolo '"
        + s.value + "'. Símbolo n° " + s.sym + " no reconocido." );
    }

    public void imprimirEtiqueta(Nodo nodo) {
        System.out.println("Se creó el nodo " + nodo.getEtiqueta());
    }

:};

terminal String PR_MAIN_IS, PR_END_PUNTO,
    PR_VARIABLE, PR_IS, PR_FUNCTION, PR_RETURN,
    PR_BEGIN, PR_END,
    PR_IF, PR_THEN, PR_ELSE, PR_WHEN, PR_WHILE,
    PR_FOR, PR_FROM, PR_TO, PR_BY, PR_DO, PR_BREAK, PR_CONTINUE,
    PR_WRITELN, PR_WRITE, PR_READ_INTEGER, PR_READ_FLOAT, PR_READ_BOOLEAN,
    OP_ARIT_SUMA, OP_ARIT_RESTA, OP_ARIT_PROD, OP_ARIT_DIV,
    OP_CMP_IGUALDAD, OP_CMP_DESIGUALDAD, OP_CMP_MAYOR, OP_CMP_MAYOR_IGUAL, OP_CMP_MENOR, OP_CMP_MENOR_IGUAL,
    OP_LOG_BIN_OR, OP_LOG_BIN_AND, OP_LOG_UNA_NOT,
    PAR_ABRE, PAR_CIERRA, PR_COMA, PUNTO_Y_COMA, IGUAL,
    IDENTIFICADOR, TIPO_DE_DATO,
    CTE_BOOLEANA, FLOTANTE, ENTERO, CADENA;

// TODO: cambiar los no terminales de String a sus tipos correspondientes
// nonterminal Programa programa;

nonterminal Expresion expresion, conjuncion, negacion_logica,
    relacion,
    adicion, termino, negacion_aritmetica,
    factor, constante, invocacion_funcion;

nonterminal List<Expresion> lista_args;

nonterminal String programa;

nonterminal String lst_decs_vars_y_funcs, dec_var, dec_fun,
    arg_dec, arg_dec_default, lst_args_dec, lst_args_dec_default,
    bloque, lst_sentencias, sentencia, bloque_when_is, operador_cmp;

precedence left PR_ELSE, PR_IS;

start with programa;

programa ::=
        lst_decs_vars_y_funcs:decs PR_MAIN_IS:pr_mainis lst_sentencias:sentencias PR_END_PUNTO:pr_end {:
             RESULT = String.join(" ", decs, pr_mainis, sentencias, pr_end);
            //RESULT = new Programa("Test");
        :}
        |
        PR_MAIN_IS:pr_mainis lst_sentencias:sentencias PR_END_PUNTO:pr_end {:
             RESULT = String.join(" ", pr_mainis, sentencias, pr_end);
//            RESULT = new Programa(new Bloque());
        :} |
        lst_decs_vars_y_funcs:decs PR_MAIN_IS:pr_mainis PR_END_PUNTO:pr_end {:
            // programa con declaraciones pero sin cuerpo principal
             RESULT = String.join(" ", decs, pr_mainis, pr_end);
//            RESULT = new Programa(new Bloque());
        :} |
        PR_MAIN_IS:pr_mainis PR_END_PUNTO:pr_end {:
            // programa mínimo, sin cuerpo
             RESULT = String.join(" ", pr_mainis, pr_end);
            // RESULT = new Programa(new Bloque());
        :};

lst_decs_vars_y_funcs ::=
        dec_var:dec_var PUNTO_Y_COMA:pyc lst_decs_vars_y_funcs:decs {:
             RESULT = String.join(" ", dec_var, pyc, decs);
        :} |
        dec_fun:dec_fun lst_decs_vars_y_funcs:decs {:
            RESULT = String.join(" ", dec_fun, decs);
        :} |
        dec_var:dec_var PUNTO_Y_COMA:pyc {:
            RESULT = String.join(" ", dec_var, pyc);
        :} |
        dec_fun:dec_fun {:
            RESULT = dec_fun;
        :};

dec_var ::=
        PR_VARIABLE:pr_var arg_dec:arg_dec {:
             RESULT = String.join(" ", pr_var, arg_dec);
        :} |
        PR_VARIABLE:pr_var arg_dec_default:arg_dec_default {:
             RESULT = String.join(" ", pr_var, arg_dec_default);
        :};

arg_dec ::=
        IDENTIFICADOR:id PR_IS:pr_is TIPO_DE_DATO:td {:
            RESULT = String.join(" ", id, pr_is, td);
        :};

arg_dec_default ::=
        IDENTIFICADOR:id PR_IS:pr_is TIPO_DE_DATO:td IGUAL:igual expresion:expr {:
            RESULT = String.join(" ", id, pr_is, td, igual, expr.getEtiqueta());
        :};

dec_fun ::=
        PR_FUNCTION:pr_funcion IDENTIFICADOR:id PAR_ABRE:pa PAR_CIERRA:pc PR_RETURN:ret TIPO_DE_DATO:td bloque:bloque PUNTO_Y_COMA:pyc {:
            RESULT = String.join(" ", pr_funcion, id, pa, pc, ret, td, bloque);
        :} |
        PR_FUNCTION:pr_funcion IDENTIFICADOR:id PAR_ABRE:pa lst_args_dec:args PAR_CIERRA:pc PR_RETURN:ret TIPO_DE_DATO:td bloque:bloque PUNTO_Y_COMA:pyc {:
            RESULT = String.join(" ", pr_funcion, id, pa, args, pc, ret, td, bloque);
        :};

lst_args_dec ::=
        arg_dec:arg PR_COMA:pr_coma lst_args_dec:args {:
            RESULT = String.join(" ", arg, pr_coma, args);
        :} |
        arg_dec:arg {:
            RESULT = arg;
        :} |
        arg_dec_default:arg PR_COMA:pr_coma lst_args_dec_default:args {:
            RESULT = String.join(" ", arg, pr_coma, args);
        :} |
        arg_dec_default:arg {:
            RESULT = String.join(" ", arg);
        :};

lst_args_dec_default ::=
        arg_dec_default:arg PR_COMA:pr_coma lst_args_dec_default:args {:
            RESULT = String.join(" ", arg, pr_coma, args);
        :} |
        arg_dec_default:arg {:
            RESULT = arg;
        :};

// sentencia simple o bloque begin/end para implementación de funciones y estructuras de selección e iteración
bloque ::=
        sentencia:sent {:
            RESULT = String.join(" ", sent);
            // System.out.println("REGLA: sentencia (" + RESULT + ") -> bloque");
        :} |
        PR_BEGIN:begin lst_sentencias:sentencias PR_END:pr_end {:
            RESULT = String.join(" ", begin, sentencias, pr_end);
            // System.out.println("REGLA: begin sentencias end (" + RESULT + ") -> bloque");
        :};

lst_sentencias ::=
        sentencia:sent PUNTO_Y_COMA:pyc lst_sentencias:sentencias {:
            RESULT = String.join(" ", sent, pyc, sentencias);
            // System.out.println("REGLA: sentencia, lst_sentencias (" + RESULT + ") -> lst_sentencias");
        :} |
        sentencia:sent PUNTO_Y_COMA:pyc {:
            RESULT = String.join(" ", sent, pyc);
            // System.out.println("REGLA: sentencia (" + RESULT + ") -> lst_sentencias");
        :};

sentencia ::=
        // asignación
        IDENTIFICADOR:id IGUAL:igual expresion:expr {:
            RESULT = String.join(" ", id, igual, expr.getEtiqueta());
        :} |
        invocacion_funcion:invo_fun {:
            RESULT = invo_fun.getEtiqueta();
        :} |
        // las variables se pueden definir en cualquier punto del programa
        dec_var:dec_var {:
            RESULT = dec_var;
        :} |
        PR_IF:pr_if expresion:expr PR_THEN:pr_then bloque:bloque {:
            RESULT = String.join(" ", pr_if, expr.getEtiqueta(), pr_then, bloque);
        :} |
        PR_IF:pr_if expresion:expr PR_THEN:pr_then bloque:bloque1 PR_ELSE:pr_else bloque:bloque2 {:
            RESULT = String.join(" ", pr_if, expr.getEtiqueta(), pr_then, bloque1, pr_else, bloque2);
        :} |
        PR_WHEN:when expresion:expr bloque_when_is:bloque_is {:
            RESULT = String.join(" ", when, expr.getEtiqueta(), bloque_is);
        :} |
        PR_WHEN:when expresion:expr bloque_when_is:bloque_is PR_ELSE:pr_else bloque:bloque {:
            RESULT = String.join(" ", when, expr.getEtiqueta(), bloque_is, pr_else, bloque);
        :} |
        PR_WHILE:pr_while expresion:expr PR_DO:pr_do bloque:bloque {:
            RESULT = String.join(" ", pr_while, expr.getEtiqueta(), pr_do, bloque);
        :} |
        PR_FOR:pr_for IDENTIFICADOR:id PR_FROM:pr_from ENTERO:num_ini PR_TO:pr_to ENTERO:num_fin PR_DO:pr_do bloque:bloque {:
            RESULT = String.join(" ", pr_for, id, pr_from, num_ini, pr_to, num_fin, pr_do, bloque);
        :} |
        PR_FOR:pr_for IDENTIFICADOR:id PR_FROM:pr_from ENTERO:num_ini PR_TO:pr_to ENTERO:num_fin PR_BY:pr_by ENTERO:salto PR_DO:pr_do bloque:bloque {:
            RESULT = String.join(" ", pr_for, id, pr_from, num_ini, pr_to, num_fin, pr_by, salto, pr_do, bloque);
        :} |
        PR_RETURN:ret expresion:expr {:
            RESULT = String.join(" ", ret, expr.getEtiqueta());
        :} |
        PR_BREAK:pr_break {:
            RESULT = pr_break;
        :} |
        PR_CONTINUE:pr_cont {:
            RESULT = pr_cont;
        :};

bloque_when_is ::=
        PR_IS:pr_is operador_cmp:comp expresion:expr PR_THEN:pr_then bloque:bloque {:
            RESULT = String.join(" ", pr_is, comp, expr.getEtiqueta(), pr_then, bloque);
        :} |
        PR_IS:pr_is operador_cmp:comp expresion:expr PR_THEN:pr_then bloque:bloque bloque_when_is:bloque_when {:
            RESULT = String.join(" ", pr_is, comp, expr.getEtiqueta(), pr_then, bloque, bloque_when);
        :};

// Tuve que armar esto porque desarmé el lexema que teníamos antes, que agrupaba a todos los operadores,
// para que quede más prolijo abajo en las relaciones, pero me olvidé que se usaba acá tmb.
// TODO: ver si se puede acomodar sin tener que replicar la regla 12 veces (2 por cada operador)
operador_cmp ::=
        OP_CMP_IGUALDAD:igual {:
        :} |
        OP_CMP_DESIGUALDAD:distinto {:
        :} |
        OP_CMP_MAYOR:mayor {:
        :} |
        OP_CMP_MAYOR_IGUAL:mayor_igual {:
        :} |
        OP_CMP_MENOR:menor {:
        :} |
        OP_CMP_MENOR_IGUAL:menor_igual {:
        :};

expresion ::=
        expresion:expr OP_LOG_BIN_OR:op_or conjuncion:con {:
            Disyuncion dis = new Disyuncion(expr, con);
            imprimirEtiqueta(dis);
            RESULT = dis;
            // System.out.println("REGLA: expresion or conjuncion (" + RESULT + ") -> expresion");
        :} |
        conjuncion:con {:
            RESULT = con;
            // System.out.println("REGLA: conjuncion (" + RESULT + ") -> expresion");
        :};

conjuncion ::=
       conjuncion:con OP_LOG_BIN_AND:op_and negacion_logica:neg_log {:
            Conjuncion conjun = new Conjuncion(con, neg_log);
            imprimirEtiqueta(conjun);
            RESULT = conjun;
       :} |
       negacion_logica:neg_log {:
            RESULT = neg_log;
       :};

negacion_logica ::=
        OP_LOG_UNA_NOT:op_not relacion:rel {:
            NegacionLogica negLog = new NegacionLogica(rel);
            imprimirEtiqueta(negLog);
            RESULT = negLog;
        :} |
        relacion:relacion {:
            RESULT = relacion;
        :};

relacion ::=
        adicion:adicion1 OP_CMP_IGUALDAD:igual adicion:adicion2 {:
            Igualdad rel = new Igualdad(adicion1, adicion2);
            imprimirEtiqueta(rel);
            RESULT = rel;
        :} |
        adicion:adicion1 OP_CMP_DESIGUALDAD:desigual adicion:adicion2 {:
            Desigualdad rel = new Desigualdad(adicion1, adicion2);
            imprimirEtiqueta(rel);
            RESULT = rel;
        :} |
        adicion:adicion1 OP_CMP_MAYOR:mayor adicion:adicion2 {:
            Mayor rel = new Mayor(adicion1, adicion2);
            imprimirEtiqueta(rel);
            RESULT = rel;
        :} |
        adicion:adicion1 OP_CMP_MAYOR_IGUAL:mayor_igual adicion:adicion2 {:
            MayorIgual rel = new MayorIgual(adicion1, adicion2);
            imprimirEtiqueta(rel);
            RESULT = rel;
        :} |
        adicion:adicion1 OP_CMP_MENOR:menor adicion:adicion2 {:
            Menor rel = new Menor(adicion1, adicion2);
            imprimirEtiqueta(rel);
            RESULT = rel;
        :} |
        adicion:adicion1 OP_CMP_MENOR_IGUAL:menor_igual adicion:adicion2 {:
            MenorIgual rel = new MenorIgual(adicion1, adicion2);
            imprimirEtiqueta(rel);
            RESULT = rel;
        :} |
        adicion:adicion {:
            RESULT = adicion;
        :};

adicion ::=
        adicion:adicion OP_ARIT_SUMA:op_suma termino:termino {:
            Suma suma = new Suma(adicion, termino);
            imprimirEtiqueta(suma);
            RESULT = suma;
        :} |
        adicion:adicion OP_ARIT_RESTA:op_resta termino:termino {:
            Resta resta = new Resta(adicion, termino);
            imprimirEtiqueta(resta);
            RESULT = resta;
        :} |
        termino:termino {:
            RESULT = termino;
        :};

termino ::=
        termino:termino OP_ARIT_PROD:op_prod negacion_aritmetica:negacion_aritmetica {:
            Multiplicacion multi = new Multiplicacion(termino, negacion_aritmetica);
            imprimirEtiqueta(multi);
            RESULT = multi;
        :} |
        termino:termino OP_ARIT_DIV:op_div negacion_aritmetica:negacion_aritmetica {:
            Division divi = new Division(termino, negacion_aritmetica);
            imprimirEtiqueta(divi);
            RESULT = divi;
        :} |
        negacion_aritmetica:negacion_aritmetica {:
            RESULT = negacion_aritmetica;
        :};

negacion_aritmetica ::=
        OP_ARIT_RESTA:menos factor:factor {:
            NegacionAritmetica negArit = new NegacionAritmetica(factor);
            imprimirEtiqueta(negArit);
            RESULT = negArit;
        :} |
        factor:factor {:
            RESULT = factor;
        :};

factor ::=
        constante:cte {:
            RESULT = cte;
        :} |
        IDENTIFICADOR:id {:
            Identificador ident = new Identificador(id);
            imprimirEtiqueta(ident);
            RESULT = new Identificador(id);
        :} |
        invocacion_funcion:invo {:
            RESULT = invo;
        :} |
        PAR_ABRE:pa expresion:expr PAR_CIERRA:pc {:
            RESULT = expr;
        :};

constante ::=
        ENTERO:lit_int {:
            Constante cte = new Constante(lit_int, Tipo.INTEGER);
            imprimirEtiqueta(cte);
            RESULT = cte;
        :} |
        FLOTANTE:lit_float {:
            Constante cte = new Constante(lit_float, Tipo.FLOAT);
            imprimirEtiqueta(cte);
            RESULT = cte;
        :} |
        CTE_BOOLEANA:lit_bool {:
            Constante cte = new Constante(lit_bool, Tipo.BOOL);
            imprimirEtiqueta(cte);
            RESULT = cte;
        :};

invocacion_funcion ::=
        PR_WRITELN:nombre_fun PAR_ABRE:pa expresion:expr PAR_CIERRA:pc {:
            List<Expresion> args = new ArrayList<>();
            args.add(expr);
            RESULT = new InvocacionFuncion(nombre_fun, args);
        :} |
        PR_WRITELN:nombre_fun PAR_ABRE:pa CADENA:c PAR_CIERRA:pc {:
            // TODO: ver esto, nuestro tipo Cadena supuestamente no es Expresion...
            List<Expresion> args = new ArrayList<>();
            args.add(new Constante(c));
            RESULT = new InvocacionFuncion(nombre_fun, args);
        :} |
        PR_WRITE:nombre_fun PAR_ABRE:pa expresion:expr PAR_CIERRA:pc {:
            List<Expresion> args = new ArrayList<>();
            args.add(expr);
            RESULT = new InvocacionFuncion(nombre_fun, args);
        :} |
        PR_WRITE:nombre_fun PAR_ABRE:pa CADENA:c PAR_CIERRA:pc {:
            // TODO: ver esto, nuestro tipo Cadena supuestamente no es Expresion...
            List<Expresion> args = new ArrayList<>();
            args.add(new Constante(c));
            RESULT = new InvocacionFuncion(nombre_fun, args);
        :} |
        PR_READ_INTEGER:nombre_fun PAR_ABRE:pa PAR_CIERRA:pc {:
            InvocacionFuncion invo = new InvocacionFuncion(nombre_fun, Tipo.INTEGER);
            imprimirEtiqueta(invo);
            RESULT = invo;
        :} |
        PR_READ_FLOAT:nombre_fun PAR_ABRE:pa PAR_CIERRA:pc {:
            InvocacionFuncion invo = new InvocacionFuncion(nombre_fun, Tipo.FLOAT);
            imprimirEtiqueta(invo);
            RESULT = invo;
        :} |
        PR_READ_BOOLEAN:nombre_fun PAR_ABRE:pa PAR_CIERRA:pc {:
            InvocacionFuncion invo = new InvocacionFuncion(nombre_fun, Tipo.BOOL);
            imprimirEtiqueta(invo);
            RESULT = invo;
        :} |
        IDENTIFICADOR:nombre_fun PAR_ABRE:pa PAR_CIERRA:pc {:
            InvocacionFuncion invo = new InvocacionFuncion(nombre_fun);
            imprimirEtiqueta(invo);
            RESULT = invo;
        :} |
        IDENTIFICADOR:nombre_fun PAR_ABRE:pa expresion:arg PAR_CIERRA:pc {:
            List<Expresion> args = new ArrayList<>();
            args.add(arg);
            InvocacionFuncion invo = new InvocacionFuncion(nombre_fun, args, Tipo.UNKNOWN);
            imprimirEtiqueta(invo);
            RESULT = invo;
        :};

//lista_args ::=
//        lista_args:args PR_COMA:pr_coma expresion:arg {:
//            args.add(arg);
//            System.out.println("Se agregó " + arg.getEtiqueta() + " en args(List<Expresion>)");
//            RESULT = args;
//        :} |
//        expresion:arg {:
//            List<Expresion> args = new ArrayList<>();
//            System.out.println("Se crea args(List<Expresion>) con un único arg");
//            args.add(arg);
//            RESULT = args;
//        :} | {:
//            List<Expresion> args = new ArrayList<>();
//            System.out.println("Se creó args(List<Expresion>) vacía");
//            RESULT = args;
//        :};
