package ar.edu.unnoba.compilador.sintaxis;

import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.List;

import ar.edu.unnoba.compilador.ast.base.Nodo;
import ar.edu.unnoba.compilador.ast.base.Programa;
import ar.edu.unnoba.compilador.ast.base.Encabezado;
import ar.edu.unnoba.compilador.ast.base.Bloque;

import ar.edu.unnoba.compilador.ast.sentencias.Sentencia;

import ar.edu.unnoba.compilador.ast.sentencias.Asignacion;
import ar.edu.unnoba.compilador.ast.sentencias.declaracion.Declaracion;
import ar.edu.unnoba.compilador.ast.sentencias.declaracion.DecFuncion;
import ar.edu.unnoba.compilador.ast.sentencias.declaracion.DecVar;
import ar.edu.unnoba.compilador.ast.sentencias.declaracion.DecVarInicializada;

import ar.edu.unnoba.compilador.ast.sentencias.seleccion.Cuando;
import ar.edu.unnoba.compilador.ast.sentencias.seleccion.CasoCuando;
import ar.edu.unnoba.compilador.ast.sentencias.seleccion.SiEntonces;
import ar.edu.unnoba.compilador.ast.sentencias.seleccion.SiEntoncesSino;

import ar.edu.unnoba.compilador.ast.sentencias.iteracion.Mientras;
import ar.edu.unnoba.compilador.ast.sentencias.iteracion.Para;

import ar.edu.unnoba.compilador.ast.sentencias.control.Salir;
import ar.edu.unnoba.compilador.ast.sentencias.control.Continuar;
import ar.edu.unnoba.compilador.ast.sentencias.control.Retorno;

import ar.edu.unnoba.compilador.ast.expresiones.Expresion;

import ar.edu.unnoba.compilador.ast.expresiones.binarias.logicas.Disyuncion;
import ar.edu.unnoba.compilador.ast.expresiones.binarias.logicas.Conjuncion;
import ar.edu.unnoba.compilador.ast.expresiones.unarias.logicas.NegacionLogica;

import ar.edu.unnoba.compilador.ast.expresiones.binarias.relaciones.Relacion;
import ar.edu.unnoba.compilador.ast.expresiones.binarias.relaciones.Desigualdad;
import ar.edu.unnoba.compilador.ast.expresiones.binarias.relaciones.Igualdad;
import ar.edu.unnoba.compilador.ast.expresiones.binarias.relaciones.Mayor;
import ar.edu.unnoba.compilador.ast.expresiones.binarias.relaciones.MayorIgual;
import ar.edu.unnoba.compilador.ast.expresiones.binarias.relaciones.Menor;
import ar.edu.unnoba.compilador.ast.expresiones.binarias.relaciones.MenorIgual;

import ar.edu.unnoba.compilador.ast.expresiones.binarias.OperacionBinaria;
import ar.edu.unnoba.compilador.ast.expresiones.binarias.aritmeticas.Suma;
import ar.edu.unnoba.compilador.ast.expresiones.binarias.aritmeticas.Resta;
import ar.edu.unnoba.compilador.ast.expresiones.binarias.aritmeticas.Multiplicacion;
import ar.edu.unnoba.compilador.ast.expresiones.binarias.aritmeticas.Division;
import ar.edu.unnoba.compilador.ast.expresiones.unarias.aritmeticas.NegacionAritmetica;

import ar.edu.unnoba.compilador.ast.expresiones.Tipo;
import ar.edu.unnoba.compilador.ast.expresiones.OperadorCmp;
import ar.edu.unnoba.compilador.ast.expresiones.valor.Identificador;
import ar.edu.unnoba.compilador.ast.expresiones.valor.Literal;
import ar.edu.unnoba.compilador.ast.expresiones.valor.InvocacionFuncion;

class Parser;

parser code
{:
    public void syntax_error(Symbol s) {
    }

    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception {
        System.out.println("Error en la línea "+ (s.left+1) + " Columna " + s.right + ". Símbolo '"
        + s.value + "'. Símbolo n° " + s.sym + " no reconocido." );
    }

    private void imprimirEtiqueta(Nodo nodo) {
        // Torto, comento esto para que no haga tanto ruido, si hay que debuguear algo lo activamos
        // System.out.println("Se creó el nodo " + nodo.getClass().getSimpleName());
    }

    public Relacion getClaseRel(OperadorCmp op, Expresion expr1, Expresion expr2) {
        // Crea una clase según sea el operador utilizado
        // Si se utiliza el operador de IGUALDAD, devuelvo una clase Igualdad, etc.
        Relacion comp;

        switch (op) {
            case IGUALDAD:
                comp = new Igualdad(expr1, expr2);
                break;
            case DESIGUALDAD:
                comp = new Desigualdad(expr1, expr2);
                break;
            case MAYOR:
                comp = new Mayor(expr1, expr2);
                break;
            case MAYOR_IGUAL:
                comp = new MayorIgual(expr1, expr2);
                break;
            case MENOR:
                comp = new Menor(expr1, expr2);
                break;
            default:
                comp = new MenorIgual(expr1, expr2);
                break;
        }

        return comp;
    }

    public Tipo getTipoDato(String tipoStr) {
        // Recibe el lexema TIPO (en forma de cadena) y devuelve el enum Tipo correspondiente
        Tipo tipo;

        switch (tipoStr.toUpperCase()) {
            case "BOOLEAN":
                tipo = Tipo.BOOLEAN;
                break;
            case "INTEGER":
                tipo = Tipo.INTEGER;
                break;
            case "FLOAT":
                tipo = Tipo.FLOAT;
                break;
            default:
                tipo = Tipo.UNKNOWN;
                break;
        }

        return tipo;
    }

    public OperadorCmp getTipoOpCmp(String opStr) {
        // Recibe el lexema OP_COMPARACION (en forma de cadena) y devuelve el enum OperadorCmp correspondiente
        OperadorCmp op;

        switch (opStr) {
            case "==":
                op = OperadorCmp.IGUALDAD;
                break;
            case "!=":
                op = OperadorCmp.DESIGUALDAD;
                break;
            case ">":
                op = OperadorCmp.MAYOR;
                break;
            case ">=":
                op = OperadorCmp.MAYOR_IGUAL;
                break;
            case "<":
                op = OperadorCmp.MENOR;
                break;
            default:
                op = OperadorCmp.MENOR_IGUAL;
                break;
        }

        return op;

    }
:};

terminal String PR_MAIN_IS, PR_END_PUNTO,
    PR_VARIABLE, PR_IS, PR_FUNCTION, PR_RETURN,
    PR_BEGIN, PR_END,
    PR_IF, PR_THEN, PR_ELSE, PR_WHEN, PR_WHILE,
    PR_FOR, PR_FROM, PR_TO, PR_BY, PR_DO, PR_BREAK, PR_CONTINUE,
    PR_WRITELN, PR_WRITE, PR_READ_INTEGER, PR_READ_FLOAT, PR_READ_BOOLEAN,
    OP_LOG_BIN_OR, OP_LOG_BIN_AND, OP_LOG_UNA_NOT,
    OP_COMPARACION,
    OP_ARIT_SUMA, OP_ARIT_RESTA, OP_ARIT_PROD, OP_ARIT_DIV,
    PAR_ABRE, PAR_CIERRA, COMA, PUNTO_Y_COMA, IGUAL,
    IDENTIFICADOR, TIPO_DE_DATO,
    LIT_BOOLEANO, LIT_FLOTANTE, LIT_ENTERO, CADENA;

nonterminal Programa programa;
nonterminal List<Declaracion> encabezado;
nonterminal Bloque cuerpo_programa, bloque;
nonterminal List<CasoCuando> bloque_cuando;

// Las producciones "sentencia" podrían ser de tipo Sentencia, pero para poder incluir
// a invocacion_funcion, que es de tipo Expresión, tengo que declararlas como Nodo...
// TODO: ver si puede reestructurarse para que quede más prolijo.
nonterminal List<Nodo> lst_sentencias;
nonterminal Nodo sentencia;

nonterminal Expresion disyuncion, conjuncion, negacion_logica,
    relacion, adicion, termino, negacion_aritmetica,
    factor, literal, invocacion_funcion;

nonterminal List<Expresion> lista_exprs;

nonterminal Sentencia asignacion, si_entonces, cuando, para, mientras, control;
nonterminal DecFuncion dec_fun;

nonterminal List<DecVar> lst_args_dec, lst_args_dec_default;
nonterminal DecVar dec_var, arg_dec, arg_dec_default;

precedence left PR_ELSE, PR_IS;
precedence right IDENTIFICADOR, OP_ARIT_RESTA, PR_VARIABLE, PR_FUNCTION;

start with programa;

programa ::=
        encabezado:decs cuerpo_programa:cpo_prog {:
            Encabezado enc = new Encabezado(decs);
            Programa prog = new Programa("Programa", enc, cpo_prog);
            imprimirEtiqueta(prog);
            RESULT = prog;
        :};

cuerpo_programa ::=
        PR_MAIN_IS:pr_main_is lst_sentencias:sentencias PR_END_PUNTO:pr_end {:
            final boolean esBloquePrincipal = true;
            Bloque cuerpoPrograma = new Bloque("Bloque principal", sentencias, esBloquePrincipal);
            imprimirEtiqueta(cuerpoPrograma);
            RESULT = cuerpoPrograma;
        :} |
        PR_MAIN_IS:pr_main_is PR_END_PUNTO:pr_end {:
            final boolean esBloquePrincipal = true;
            Bloque cuerpoPrograma = new Bloque("Bloque principal (vacío)", esBloquePrincipal);
            imprimirEtiqueta(cuerpoPrograma);
            RESULT = cuerpoPrograma;
        :};

encabezado ::=
        encabezado:decs dec_var:dec_var PUNTO_Y_COMA:pyc{:
            decs.add(dec_var);
            imprimirEtiqueta(dec_var);
            RESULT = decs;
        :} |
        encabezado:decs dec_fun:dec_fun {:
            decs.add(dec_fun);
            imprimirEtiqueta(dec_fun);
            RESULT = decs;
        :} |
        dec_var:dec_var PUNTO_Y_COMA:pyc {:
            List<Declaracion> decs = new ArrayList<>();
            decs.add(dec_var);
            imprimirEtiqueta(dec_var);
            RESULT = decs;
        :} |
        dec_fun:dec_fun {:
            List<Declaracion> decs = new ArrayList<>();
            decs.add(dec_fun);
            imprimirEtiqueta(dec_fun);
            RESULT = decs;
        :} |
        {:
            // Encabezado vacío
            List<Declaracion> decs = new ArrayList<>();
            RESULT = decs;
        :};

dec_var ::=
        PR_VARIABLE:pr_var arg_dec:arg_dec {:
            RESULT = arg_dec;
        :} |
        PR_VARIABLE:pr_var arg_dec_default:arg_dec_default {:
            RESULT = arg_dec_default;
        :};

arg_dec ::=
        IDENTIFICADOR:id PR_IS:pr_is TIPO_DE_DATO:td {:
            Identificador ident = new Identificador(id, getTipoDato(td));
            DecVar decVar = new DecVar("Variable sin inicializar", ident);
            imprimirEtiqueta(decVar);
            RESULT = decVar;
        :};

arg_dec_default ::=
        IDENTIFICADOR:id PR_IS:pr_is TIPO_DE_DATO:td IGUAL:igual disyuncion:disy {:
            Identificador ident = new Identificador(id, getTipoDato(td));
            DecVarInicializada decVar = new DecVarInicializada("Variable inicializada", ident, disy);
            imprimirEtiqueta(decVar);
            RESULT = decVar;
        :};

dec_fun ::=
        PR_FUNCTION:pr_funcion IDENTIFICADOR:id PAR_ABRE:pa PAR_CIERRA:pc PR_RETURN:ret TIPO_DE_DATO:td bloque:bloque PUNTO_Y_COMA:pyc {:
            Identificador ident = new Identificador(id, getTipoDato(td));
            DecFuncion decFun = new DecFuncion(ident, bloque);
            imprimirEtiqueta(decFun);
            RESULT = decFun;
        :} |
        PR_FUNCTION:pr_funcion IDENTIFICADOR:id PAR_ABRE:pa lst_args_dec:args PAR_CIERRA:pc PR_RETURN:ret TIPO_DE_DATO:td bloque:bloque PUNTO_Y_COMA:pyc {:
            Identificador ident = new Identificador(id, getTipoDato(td));
            DecFuncion decFun = new DecFuncion(ident, args, bloque);
            imprimirEtiqueta(decFun);
            RESULT = decFun;
        :};

lst_args_dec ::=
        arg_dec:arg COMA:coma lst_args_dec:args {:
            args.add(arg);
            imprimirEtiqueta(arg);
            RESULT = args;
        :} |
        arg_dec:arg {:
            List<DecVar> args = new ArrayList<>();
            args.add(arg);
            imprimirEtiqueta(arg);
            RESULT = args;
        :} |
        arg_dec_default:arg COMA:coma lst_args_dec_default:args {:
            args.add(arg);
            imprimirEtiqueta(arg);
            RESULT = args;
        :} |
        arg_dec_default:arg {:
            List<DecVar> args = new ArrayList<>();
            args.add(arg);
            imprimirEtiqueta(arg);
            RESULT = args;
        :};

lst_args_dec_default ::=
        arg_dec_default:arg COMA:coma lst_args_dec_default:args {:
            args.add(arg);
            imprimirEtiqueta(arg);
            RESULT = args;
        :} |
        arg_dec_default:arg {:
            List<DecVar> args = new ArrayList<>();
            args.add(arg);
            imprimirEtiqueta(arg);
            RESULT = args;
        :};

bloque ::=
        sentencia:sent {:
            List<Nodo> sentencias = new ArrayList<>();
            sentencias.add(sent);
            final boolean esBloquePrincipal = false;
            Bloque bloque = new Bloque("Bloque simple\n(una sentencia)", sentencias, esBloquePrincipal);
            RESULT = bloque;
        :} |
        PR_BEGIN:begin lst_sentencias:sentencias PR_END:pr_end {:
            final boolean esBloquePrincipal = false;
            Bloque bloque = new Bloque("Bloque compuesto\n(múltiples sentencias)", sentencias, esBloquePrincipal);
            RESULT = bloque;
        :};

lst_sentencias ::=
        lst_sentencias:sentencias sentencia:sent PUNTO_Y_COMA:pyc {:
            sentencias.add(sent);
            RESULT = sentencias;
        :} |
        sentencia:sent PUNTO_Y_COMA:pyc {:
            List<Nodo> sentencias = new ArrayList<>();
            sentencias.add(sent);
            RESULT = sentencias;
        :};

sentencia ::=
        asignacion:asig {:
            RESULT = asig;
        :} |
        invocacion_funcion:invo_fun {:
            RESULT = invo_fun;
        :} |
        dec_var:dec_var {:
            RESULT = dec_var;
        :} |
        si_entonces:si {:
            RESULT = si;
        :} |
        cuando:cuando {:
            RESULT = cuando;
        :} |
        para:para {:
            RESULT = para;
        :} |
        mientras:mientras {:
            RESULT = mientras;
        :} |
        control:ctrl {:
            RESULT = ctrl;
        :};

asignacion ::=
        IDENTIFICADOR:id IGUAL:igual disyuncion:disy {:
            Identificador ident = new Identificador(id);
            Asignacion asig = new Asignacion(ident, disy);
            imprimirEtiqueta(asig);
            RESULT = asig;
       :};

si_entonces ::=
        PR_IF:pr_if disyuncion:disy PR_THEN:pr_then bloque:bloque {:
            SiEntonces se = new SiEntonces(disy, bloque);
            imprimirEtiqueta(se);
            RESULT = se;
        :} |
        PR_IF:pr_if disyuncion:disy PR_THEN:pr_then bloque:bloque1 PR_ELSE:pr_else bloque:bloque2 {:
            SiEntoncesSino se = new SiEntoncesSino(disy, bloque1, bloque2);
            imprimirEtiqueta(se);
            RESULT = se;
        :};

cuando ::=
        PR_WHEN:when disyuncion:disy bloque_cuando:bloque_cuando {:
            Cuando cuando = new Cuando(disy, bloque_cuando);
            imprimirEtiqueta(cuando);
            RESULT = cuando;
        :} |
        PR_WHEN:when disyuncion:disy bloque_cuando:bloque_cuando PR_ELSE:pr_else bloque:bloque_else {:
            Cuando cuando = new Cuando(disy, bloque_cuando, bloque_else);
            imprimirEtiqueta(cuando);
            RESULT = cuando;
        :};

bloque_cuando ::=
        PR_IS:pr_is OP_COMPARACION:op disyuncion:disy PR_THEN:pr_then bloque:bloque {:
            List<CasoCuando> bloqueCuando = new ArrayList<>();
            CasoCuando caso = new CasoCuando(getTipoOpCmp(op), disy, bloque);
            imprimirEtiqueta(caso);
            bloqueCuando.add(caso);
            RESULT = bloqueCuando;
        :} |
        PR_IS:pr_is OP_COMPARACION:op disyuncion:disy PR_THEN:pr_then bloque:bloque bloque_cuando:bloqueCuando {:
            CasoCuando caso = new CasoCuando(getTipoOpCmp(op), disy, bloque);
            imprimirEtiqueta(caso);
            bloqueCuando.add(caso);
            RESULT = bloqueCuando;
        :};

para ::=
        PR_FOR:pr_for IDENTIFICADOR:id PR_FROM:pr_from LIT_ENTERO:num_ini PR_TO:pr_to LIT_ENTERO:num_fin PR_DO:pr_do bloque:bloque {:
            int saltoPorDefecto = 1;
            Identificador ident = new Identificador(id);
            Para para = new Para("Bloque FOR con salto sin definir", ident, Integer.parseInt(num_ini),
                                Integer.parseInt(num_fin), saltoPorDefecto, bloque);
            imprimirEtiqueta(para);
            RESULT = para;
        :} |
        PR_FOR:pr_for IDENTIFICADOR:id PR_FROM:pr_from LIT_ENTERO:num_ini PR_TO:pr_to LIT_ENTERO:num_fin PR_BY:pr_by LIT_ENTERO:salto PR_DO:pr_do bloque:bloque {:
            Identificador ident = new Identificador(id);
            Para para = new Para("Bloque FOR con salto definido", ident, Integer.parseInt(num_ini),
                                Integer.parseInt(num_fin), Integer.parseInt(salto), bloque);
            imprimirEtiqueta(para);
            RESULT = para;
        :};

mientras ::=
        PR_WHILE:pr_while disyuncion:disy PR_DO:pr_do bloque:bloque {:
            Mientras mientras = new Mientras(disy, bloque);
            imprimirEtiqueta(mientras);
            RESULT = mientras;
        :};

control ::=
        PR_RETURN:pr_ret disyuncion:disy {:
            Retorno ret = new Retorno(disy);
            imprimirEtiqueta(ret);
            RESULT = ret;
        :} |
        PR_BREAK:pr_brk {:
            Salir brk = new Salir();
            imprimirEtiqueta(brk);
            RESULT = brk;
        :} |
        PR_CONTINUE:pr_cnt {:
            Continuar ctn = new Continuar();
            imprimirEtiqueta(ctn);
            RESULT = ctn;
        :};

disyuncion ::=
        disyuncion:disy OP_LOG_BIN_OR:op_or conjuncion:con {:
            Disyuncion dis = new Disyuncion(disy, con);
            imprimirEtiqueta(dis);
            RESULT = dis;
        :} |
        conjuncion:con {:
            RESULT = con;
        :};

conjuncion ::=
       conjuncion:con OP_LOG_BIN_AND:op_and negacion_logica:neg_log {:
            Conjuncion conjun = new Conjuncion(con, neg_log);
            imprimirEtiqueta(conjun);
            RESULT = conjun;
       :} |
       negacion_logica:neg_log {:
            RESULT = neg_log;
       :};

negacion_logica ::=
        OP_LOG_UNA_NOT:op_not relacion:rel {:
            NegacionLogica negLog = new NegacionLogica(rel);
            imprimirEtiqueta(negLog);
            RESULT = negLog;
        :} |
        relacion:relacion {:
            RESULT = relacion;
        :};

relacion ::=
        adicion:adicion1 OP_COMPARACION:op adicion:adicion2 {:
            OperacionBinaria rel = getClaseRel(getTipoOpCmp(op), adicion1, adicion2);
            imprimirEtiqueta(rel);
            RESULT = rel;
        :} |
        adicion:adicion {:
            RESULT = adicion;
        :};

adicion ::=
        adicion:adicion OP_ARIT_SUMA:op_suma termino:termino {:
            Suma suma = new Suma(adicion, termino);
            imprimirEtiqueta(suma);
            RESULT = suma;
        :} |
        adicion:adicion OP_ARIT_RESTA:op_resta termino:termino {:
            Resta resta = new Resta(adicion, termino);
            imprimirEtiqueta(resta);
            RESULT = resta;
        :} |
        termino:termino {:
            RESULT = termino;
        :};

termino ::=
        termino:termino OP_ARIT_PROD:op_prod negacion_aritmetica:negacion_aritmetica {:
            Multiplicacion multi = new Multiplicacion(termino, negacion_aritmetica);
            imprimirEtiqueta(multi);
            RESULT = multi;
        :} |
        termino:termino OP_ARIT_DIV:op_div negacion_aritmetica:negacion_aritmetica {:
            Division divi = new Division(termino, negacion_aritmetica);
            imprimirEtiqueta(divi);
            RESULT = divi;
        :} |
        negacion_aritmetica:negacion_aritmetica {:
            RESULT = negacion_aritmetica;
        :};

negacion_aritmetica ::=
        OP_ARIT_RESTA:menos factor:factor {:
            NegacionAritmetica negArit = new NegacionAritmetica(factor);
            imprimirEtiqueta(negArit);
            RESULT = negArit;
        :} |
        factor:factor {:
            RESULT = factor;
        :};

factor ::=
        literal:lit {:
            RESULT = lit;
        :} |
        IDENTIFICADOR:id {:
            Identificador ident = new Identificador(id);
            imprimirEtiqueta(ident);
            RESULT = ident;
        :} |
        invocacion_funcion:invo {:
            RESULT = invo;
        :} |
        PAR_ABRE:pa disyuncion:disy PAR_CIERRA:pc {:
            RESULT = disy;
        :};

literal ::=
        LIT_ENTERO:lit_int {:
            Literal lit = new Literal(lit_int, Tipo.INTEGER, "Literal INTEGER");
            imprimirEtiqueta(lit);
            RESULT = lit;
        :} |
        LIT_FLOTANTE:lit_float {:
            Literal lit = new Literal(lit_float, Tipo.FLOAT, "Literal FLOAT");
            imprimirEtiqueta(lit);
            RESULT = lit;
        :} |
        LIT_BOOLEANO:lit_bool {:
            Literal lit = new Literal(lit_bool, Tipo.BOOLEAN, "Literal BOOLEAN");
            imprimirEtiqueta(lit);
            RESULT = lit;
        :};

invocacion_funcion ::=
        PR_WRITELN:nombre_fun PAR_ABRE:pa disyuncion:disy PAR_CIERRA:pc {:
            List<Expresion> args = new ArrayList<>();
            args.add(disy);
            RESULT = new InvocacionFuncion(nombre_fun, args, Tipo.UNKNOWN);
        :} |
        PR_WRITELN:nombre_fun PAR_ABRE:pa CADENA:c PAR_CIERRA:pc {:
            List<String> args = new ArrayList<>();
            args.add("\\\"" + c + "\\\"");
            RESULT = new InvocacionFuncion(nombre_fun, args, Tipo.UNKNOWN);
        :} |
        PR_WRITE:nombre_fun PAR_ABRE:pa disyuncion:disy PAR_CIERRA:pc {:
            List<Expresion> args = new ArrayList<>();
            args.add(disy);
            RESULT = new InvocacionFuncion(nombre_fun, args, Tipo.UNKNOWN);
        :} |
        PR_WRITE:nombre_fun PAR_ABRE:pa CADENA:c PAR_CIERRA:pc {:
            List<String> args = new ArrayList<>();
            args.add("\\\"" + c + "\\\"");
            RESULT = new InvocacionFuncion(nombre_fun, args, Tipo.UNKNOWN);
        :} |
        PR_READ_INTEGER:nombre_fun PAR_ABRE:pa PAR_CIERRA:pc {:
            InvocacionFuncion invo = new InvocacionFuncion(nombre_fun, Tipo.INTEGER);
            imprimirEtiqueta(invo);
            RESULT = invo;
        :} |
        PR_READ_FLOAT:nombre_fun PAR_ABRE:pa PAR_CIERRA:pc {:
            InvocacionFuncion invo = new InvocacionFuncion(nombre_fun, Tipo.FLOAT);
            imprimirEtiqueta(invo);
            RESULT = invo;
        :} |
        PR_READ_BOOLEAN:nombre_fun PAR_ABRE:pa PAR_CIERRA:pc {:
            InvocacionFuncion invo = new InvocacionFuncion(nombre_fun, Tipo.BOOLEAN);
            imprimirEtiqueta(invo);
            RESULT = invo;
        :} |
        IDENTIFICADOR:nombre_fun PAR_ABRE:pa lista_exprs:args PAR_CIERRA:pc {:
            Boolean esPredefinida = false;
            InvocacionFuncion invo = new InvocacionFuncion(nombre_fun, args, Tipo.UNKNOWN, esPredefinida);
            imprimirEtiqueta(invo);
            RESULT = invo;
        :};

// Expresiones que se pasan como parámetro a una función
lista_exprs ::=
        lista_exprs:args COMA:coma disyuncion:arg {:
            args.add(arg);
            RESULT = args;
        :} |
        disyuncion:arg {:
            List<Expresion> args = new ArrayList<>();
            args.add(arg);
            RESULT = args;
        :} |
        {:
            // Para que acepte la producción cuando no se pasa ningún argumento,
            // y a la vez genere una lista vacía para pasarle al constructor.
            List<Expresion> args = new ArrayList<>();
            RESULT = args;
        :};
