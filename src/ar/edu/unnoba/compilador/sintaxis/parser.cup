package ar.edu.unnoba.compilador.sintaxis;

import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.ArrayList;

import ar.edu.unnoba.compilador.ast.base.Nodo;
import ar.edu.unnoba.compilador.ast.base.Programa;
import ar.edu.unnoba.compilador.ast.base.Encabezado;
import ar.edu.unnoba.compilador.ast.base.Bloque;

import ar.edu.unnoba.compilador.ast.sentencias.Sentencia;

import ar.edu.unnoba.compilador.ast.sentencias.Asignacion;
import ar.edu.unnoba.compilador.ast.sentencias.declaracion.Declaracion;
import ar.edu.unnoba.compilador.ast.sentencias.declaracion.DecFun;
import ar.edu.unnoba.compilador.ast.sentencias.declaracion.DecVar;
import ar.edu.unnoba.compilador.ast.sentencias.declaracion.DecVarIni;
import ar.edu.unnoba.compilador.ast.sentencias.declaracion.Param;
import ar.edu.unnoba.compilador.ast.sentencias.declaracion.ParamDef;

import ar.edu.unnoba.compilador.ast.sentencias.seleccion.Cuando;
import ar.edu.unnoba.compilador.ast.sentencias.seleccion.CasoCuando;
import ar.edu.unnoba.compilador.ast.sentencias.seleccion.SiEntonces;
import ar.edu.unnoba.compilador.ast.sentencias.seleccion.SiEntoncesSino;

import ar.edu.unnoba.compilador.ast.sentencias.iteracion.Mientras;
import ar.edu.unnoba.compilador.ast.sentencias.iteracion.Para;

import ar.edu.unnoba.compilador.ast.sentencias.control.Salir;
import ar.edu.unnoba.compilador.ast.sentencias.control.Continuar;
import ar.edu.unnoba.compilador.ast.sentencias.control.Retorno;

import ar.edu.unnoba.compilador.ast.expresiones.Expresion;

import ar.edu.unnoba.compilador.ast.expresiones.binarias.logicas.Disyuncion;
import ar.edu.unnoba.compilador.ast.expresiones.binarias.logicas.Conjuncion;
import ar.edu.unnoba.compilador.ast.expresiones.unarias.logicas.NegacionLogica;

import ar.edu.unnoba.compilador.ast.expresiones.binarias.relaciones.Relacion;
import ar.edu.unnoba.compilador.ast.expresiones.binarias.relaciones.Desigualdad;
import ar.edu.unnoba.compilador.ast.expresiones.binarias.relaciones.Igualdad;
import ar.edu.unnoba.compilador.ast.expresiones.binarias.relaciones.Mayor;
import ar.edu.unnoba.compilador.ast.expresiones.binarias.relaciones.MayorIgual;
import ar.edu.unnoba.compilador.ast.expresiones.binarias.relaciones.Menor;
import ar.edu.unnoba.compilador.ast.expresiones.binarias.relaciones.MenorIgual;

import ar.edu.unnoba.compilador.ast.expresiones.binarias.OperacionBinaria;
import ar.edu.unnoba.compilador.ast.expresiones.binarias.aritmeticas.Suma;
import ar.edu.unnoba.compilador.ast.expresiones.binarias.aritmeticas.Resta;
import ar.edu.unnoba.compilador.ast.expresiones.binarias.aritmeticas.Multiplicacion;
import ar.edu.unnoba.compilador.ast.expresiones.binarias.aritmeticas.Division;
import ar.edu.unnoba.compilador.ast.expresiones.unarias.aritmeticas.NegacionAritmetica;

import ar.edu.unnoba.compilador.ast.expresiones.Tipo;
import ar.edu.unnoba.compilador.ast.expresiones.OperadorCmp;
import ar.edu.unnoba.compilador.ast.expresiones.valor.Cadena;
import ar.edu.unnoba.compilador.ast.expresiones.valor.Identificador;
import ar.edu.unnoba.compilador.ast.expresiones.valor.Literal;
import ar.edu.unnoba.compilador.ast.expresiones.valor.InvocacionFuncion;

class Parser;

parser code
{:
    // Constante que indica si se muestra el proceso de creación de nodos.
    private final boolean mostrarCreacionNodos = false;

    public void syntax_error(Symbol s) {
    }

    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception {
        System.out.println("Error en la línea "+ (s.left+1) + " Columna " + s.right + ". Símbolo '"
        + s.value + "'. Símbolo n° " + s.sym + " no reconocido." );
    }

    // Depurar creación de nodos
    private void imprimirEtiqueta(Nodo nodo) {
        if (mostrarCreacionNodos) {
            System.out.println("Se creó el nodo " + nodo.getClass().getSimpleName());
        }
    }
:};

terminal String PR_MAIN_IS, PR_END_PUNTO,
    PR_VARIABLE, PR_IS, PR_FUNCTION, PR_RETURN,
    PR_BEGIN, PR_END,
    PR_IF, PR_THEN, PR_ELSE, PR_WHEN, PR_WHILE,
    PR_FOR, PR_FROM, PR_TO, PR_BY, PR_DO, PR_BREAK, PR_CONTINUE,
    PR_WRITELN, PR_WRITE, PR_READ_INTEGER, PR_READ_FLOAT, PR_READ_BOOLEAN,
    OP_LOG_BIN_OR, OP_LOG_BIN_AND, OP_LOG_UNA_NOT,
    OP_COMPARACION,
    OP_ARIT_SUMA, OP_ARIT_RESTA, OP_ARIT_PROD, OP_ARIT_DIV,
    PAR_ABRE, PAR_CIERRA, COMA, PUNTO_Y_COMA, IGUAL,
    IDENTIFICADOR, TIPO_DE_DATO,
    LIT_BOOLEANO, LIT_FLOTANTE, LIT_ENTERO, CADENA;

nonterminal Programa programa;

nonterminal ArrayList<Declaracion> encabezado;
nonterminal DecVar dec_var;
nonterminal DecFun dec_fun;
nonterminal ArrayList<Param> lst_params, lst_params_def;
nonterminal Param param, param_def;

nonterminal Bloque cuerpo_programa, bloque;
nonterminal ArrayList<Nodo> lst_sentencias;
nonterminal Nodo sentencia;

nonterminal Sentencia asignacion, si_entonces, cuando, para, mientras, control;
nonterminal ArrayList<CasoCuando> bloque_cuando;

nonterminal Expresion expresion, disyuncion, conjuncion, negacion_logica,
    relacion, adicion, termino, negacion_aritmetica,
    factor, literal, invocacion_funcion;

nonterminal ArrayList<Expresion> lst_args;

precedence left PR_ELSE, PR_IS;

start with programa;

programa ::=
        encabezado:decs cuerpo_programa:cpoProg {:
            Encabezado enc = new Encabezado(decs);
            Programa prog = new Programa("Programa", enc, cpoProg);
            imprimirEtiqueta(prog);
            RESULT = prog;
        :} |
        cuerpo_programa:cpoProg {:
            Encabezado enc = new Encabezado(new ArrayList<Declaracion>());
            Programa prog = new Programa("Programa", enc, cpoProg);
            imprimirEtiqueta(prog);
            RESULT = prog;
        :};

cuerpo_programa ::=
        PR_MAIN_IS lst_sentencias:sentencias PR_END_PUNTO {:
            final boolean esBloquePrincipal = true;
            Bloque cuerpoPrograma = new Bloque("Bloque principal", sentencias, esBloquePrincipal);
            imprimirEtiqueta(cuerpoPrograma);
            RESULT = cuerpoPrograma;
        :} |
        PR_MAIN_IS PR_END_PUNTO {:
            final boolean esBloquePrincipal = true;
            Bloque cuerpoPrograma = new Bloque("Bloque principal (vacío)", esBloquePrincipal);
            imprimirEtiqueta(cuerpoPrograma);
            RESULT = cuerpoPrograma;
        :};

encabezado ::=
        encabezado:decs dec_var:decVar PUNTO_Y_COMA {:
            decs.add(decVar);
            imprimirEtiqueta(decVar);
            RESULT = decs;
        :} |
        encabezado:decs dec_fun:decFun {:
            decs.add(decFun);
            imprimirEtiqueta(decFun);
            RESULT = decs;
        :} |
        dec_var:decVar PUNTO_Y_COMA {:
            ArrayList<Declaracion> decs = new ArrayList<>();
            decs.add(decVar);
            imprimirEtiqueta(decVar);
            RESULT = decs;
        :} |
        dec_fun:decFun {:
            ArrayList<Declaracion> decs = new ArrayList<>();
            decs.add(decFun);
            imprimirEtiqueta(decFun);
            RESULT = decs;
        :};

dec_var ::=
        PR_VARIABLE IDENTIFICADOR:id PR_IS TIPO_DE_DATO:td {:
            Identificador ident = new Identificador(id, Tipo.getTipoDato(td));
            DecVar decVar = new DecVar("Variable sin inicializar", ident);
            imprimirEtiqueta(decVar);
            RESULT = decVar;
        :} |
        PR_VARIABLE IDENTIFICADOR:id PR_IS TIPO_DE_DATO:td IGUAL expresion:expr {:
            Identificador ident = new Identificador(id, Tipo.getTipoDato(td));
            DecVarIni decVarIni = new DecVarIni("Variable inicializada", ident, expr);
            imprimirEtiqueta(decVarIni);
            RESULT = decVarIni;
        :};

dec_fun ::=
        PR_FUNCTION IDENTIFICADOR:id PAR_ABRE PAR_CIERRA PR_RETURN TIPO_DE_DATO:td bloque:bloque PUNTO_Y_COMA {:
            Identificador ident = new Identificador(id, Tipo.getTipoDato(td));
            DecFun decFun = new DecFun(ident, bloque);
            imprimirEtiqueta(decFun);
            RESULT = decFun;
        :} |
        PR_FUNCTION IDENTIFICADOR:id PAR_ABRE lst_params:params PAR_CIERRA PR_RETURN TIPO_DE_DATO:td bloque:bloque PUNTO_Y_COMA {:
            Identificador ident = new Identificador(id, Tipo.getTipoDato(td));
            DecFun decFun = new DecFun(ident, params, bloque);
            imprimirEtiqueta(decFun);
            RESULT = decFun;
        :};

lst_params ::=
        param:param {:
            ArrayList<Param> params = new ArrayList<>();
            params.add(param);
            imprimirEtiqueta(param);
            RESULT = params;
        :} |
        param:param COMA lst_params:params {:
            params.add(param);
            imprimirEtiqueta(param);
            RESULT = params;
        :} |
        lst_params_def:params {:
          RESULT = params;
        :};

lst_params_def ::=
        param_def:param COMA lst_params_def:params {:
            params.add(param);
            imprimirEtiqueta(param);
            RESULT = params;
        :} |
        param_def:param {:
            ArrayList<Param> params = new ArrayList<>();
            params.add(param);
            imprimirEtiqueta(param);
            RESULT = params;
        :};

param ::= IDENTIFICADOR:id PR_IS TIPO_DE_DATO:td {:
            Identificador ident = new Identificador(id, Tipo.getTipoDato(td));
            Param param = new Param("Parámetro sin valor por defecto", ident);
            imprimirEtiqueta(param);
            RESULT = param;
        :};

param_def ::= IDENTIFICADOR:id PR_IS TIPO_DE_DATO:td IGUAL expresion:expr {:
            Identificador ident = new Identificador(id, Tipo.getTipoDato(td));
            ParamDef paramDef = new ParamDef("Parámetro con valor por defecto", ident, expr);
            imprimirEtiqueta(paramDef);
            RESULT = paramDef;
        :};

bloque ::=
        sentencia:sent {:
            ArrayList<Nodo> sentencias = new ArrayList<>();
            sentencias.add(sent);
            final boolean esBloquePrincipal = false;
            Bloque bloque = new Bloque("Bloque simple\n(una sentencia)", sentencias, esBloquePrincipal);
            RESULT = bloque;
        :} |
        PR_BEGIN lst_sentencias:sentencias PR_END {:
            final boolean esBloquePrincipal = false;
            Bloque bloque = new Bloque("Bloque compuesto\n(múltiples sentencias)", sentencias, esBloquePrincipal);
            RESULT = bloque;
        :};

lst_sentencias ::=
        lst_sentencias:sentencias sentencia:sent PUNTO_Y_COMA {:
            sentencias.add(sent);
            RESULT = sentencias;
        :} |
        sentencia:sent PUNTO_Y_COMA {:
            ArrayList<Nodo> sentencias = new ArrayList<>();
            sentencias.add(sent);
            RESULT = sentencias;
        :};

sentencia ::=
        asignacion:asig {:
            RESULT = asig;
        :} |
        invocacion_funcion:invo_fun {:
            RESULT = invo_fun;
        :} |
        dec_var:dec_var {:
            RESULT = dec_var;
        :} |
        si_entonces:si {:
            RESULT = si;
        :} |
        cuando:cuando {:
            RESULT = cuando;
        :} |
        para:para {:
            RESULT = para;
        :} |
        mientras:mientras {:
            RESULT = mientras;
        :} |
        control:ctrl {:
            RESULT = ctrl;
        :};

asignacion ::=
        IDENTIFICADOR:id IGUAL expresion:expr {:
            Identificador ident = new Identificador(id);
            Asignacion asig = new Asignacion(ident, expr);
            imprimirEtiqueta(asig);
            RESULT = asig;
       :};

si_entonces ::=
        PR_IF expresion:cond PR_THEN bloque:bloque {:
            SiEntonces se = new SiEntonces(cond, bloque);
            imprimirEtiqueta(se);
            RESULT = se;
        :} |
        PR_IF expresion:cond PR_THEN bloque:bloqueSi PR_ELSE bloque:bloqueSino {:
            SiEntoncesSino se = new SiEntoncesSino(cond, bloqueSi, bloqueSino);
            imprimirEtiqueta(se);
            RESULT = se;
        :};

cuando ::=
        PR_WHEN expresion:cond bloque_cuando:bloqueCuando {:
            Cuando cuando = new Cuando(cond, bloqueCuando);
            imprimirEtiqueta(cuando);
            RESULT = cuando;
        :} |
        PR_WHEN expresion:cond bloque_cuando:bloqueCuando PR_ELSE bloque:bloqueSino {:
            Cuando cuando = new Cuando(cond, bloqueCuando, bloqueSino);
            imprimirEtiqueta(cuando);
            RESULT = cuando;
        :};

bloque_cuando ::=
        PR_IS OP_COMPARACION:op expresion:cond PR_THEN bloque:bloque {:
            ArrayList<CasoCuando> bloqueCuando = new ArrayList<>();
            CasoCuando caso = new CasoCuando(OperadorCmp.getTipoOpCmp(op), cond, bloque);
            imprimirEtiqueta(caso);
            bloqueCuando.add(caso);
            RESULT = bloqueCuando;
        :} |
        PR_IS OP_COMPARACION:op expresion:cond PR_THEN bloque:bloque bloque_cuando:bloqueCuando {:
            CasoCuando caso = new CasoCuando(OperadorCmp.getTipoOpCmp(op), cond, bloque);
            imprimirEtiqueta(caso);
            bloqueCuando.add(caso);
            RESULT = bloqueCuando;
        :};

para ::=
        PR_FOR IDENTIFICADOR:id PR_FROM LIT_ENTERO:numIni PR_TO LIT_ENTERO:numFin PR_DO bloque:bloque {:
            int saltoPorDefecto = 1;
            Identificador ident = new Identificador(id);
            Para para = new Para(ident, Integer.parseInt(numIni),
                                Integer.parseInt(numFin), saltoPorDefecto, bloque);
            imprimirEtiqueta(para);
            RESULT = para;
        :} |
        PR_FOR IDENTIFICADOR:id PR_FROM LIT_ENTERO:numIni PR_TO LIT_ENTERO:numFin PR_BY LIT_ENTERO:salto PR_DO bloque:bloque {:
            Identificador ident = new Identificador(id);
            Para para = new Para(ident, Integer.parseInt(numIni),
                                Integer.parseInt(numFin), Integer.parseInt(salto), bloque);
            imprimirEtiqueta(para);
            RESULT = para;
        :};

mientras ::=
        PR_WHILE expresion:cond PR_DO bloque:bloque {:
            Mientras mientras = new Mientras(cond, bloque);
            imprimirEtiqueta(mientras);
            RESULT = mientras;
        :};

control ::=
        PR_RETURN expresion:expr {:
            Retorno ret = new Retorno(expr);
            imprimirEtiqueta(ret);
            RESULT = ret;
        :} |
        PR_BREAK {:
            Salir brk = new Salir();
            imprimirEtiqueta(brk);
            RESULT = brk;
        :} |
        PR_CONTINUE {:
            Continuar ctn = new Continuar();
            imprimirEtiqueta(ctn);
            RESULT = ctn;
        :};

// Pongo este "alias" porque queda raro llamar a la expresión disyunción en
// las otras reglas, pero tampoco quiero renombrar a la disyunción expresión.
expresion ::=
        disyuncion:disy {:
            RESULT = disy;
        :};

disyuncion ::=
        disyuncion:disy OP_LOG_BIN_OR conjuncion:con {:
            Disyuncion dis = new Disyuncion(disy, con);
            imprimirEtiqueta(dis);
            RESULT = dis;
        :} |
        conjuncion:con {:
            RESULT = con;
        :};

conjuncion ::=
       conjuncion:con OP_LOG_BIN_AND negacion_logica:neg {:
            Conjuncion conjun = new Conjuncion(con, neg);
            imprimirEtiqueta(conjun);
            RESULT = conjun;
       :} |
       negacion_logica:neg {:
            RESULT = neg;
       :};

negacion_logica ::=
        OP_LOG_UNA_NOT negacion_logica:neg {:
            NegacionLogica negLog = new NegacionLogica(neg);
            imprimirEtiqueta(negLog);
            RESULT = negLog;
        :} |
        relacion:relacion {:
            RESULT = relacion;
        :};

relacion ::=
        adicion:adicionIzq OP_COMPARACION:op adicion:adicionDer {:
            OperacionBinaria rel = Relacion.getClaseRel(OperadorCmp.getTipoOpCmp(op), adicionIzq, adicionDer);
            imprimirEtiqueta(rel);
            RESULT = rel;
        :} |
        adicion:adicion {:
            RESULT = adicion;
        :};

adicion ::=
        adicion:adicion OP_ARIT_SUMA termino:termino {:
            Suma suma = new Suma(adicion, termino);
            imprimirEtiqueta(suma);
            RESULT = suma;
        :} |
        adicion:adicion OP_ARIT_RESTA termino:termino {:
            Resta resta = new Resta(adicion, termino);
            imprimirEtiqueta(resta);
            RESULT = resta;
        :} |
        termino:termino {:
            RESULT = termino;
        :};

termino ::=
        termino:termino OP_ARIT_PROD negacion_aritmetica:neg {:
            Multiplicacion multi = new Multiplicacion(termino, neg);
            imprimirEtiqueta(multi);
            RESULT = multi;
        :} |
        termino:termino OP_ARIT_DIV negacion_aritmetica:neg {:
            Division divi = new Division(termino, neg);
            imprimirEtiqueta(divi);
            RESULT = divi;
        :} |
        negacion_aritmetica:negacion_aritmetica {:
            RESULT = negacion_aritmetica;
        :};

negacion_aritmetica ::=
        OP_ARIT_RESTA negacion_aritmetica:neg {:
            NegacionAritmetica negArit = new NegacionAritmetica(neg);
            imprimirEtiqueta(negArit);
            RESULT = negArit;
        :} |
        factor:factor {:
            RESULT = factor;
        :};

factor ::=
        literal:lit {:
            RESULT = lit;
        :} |
        IDENTIFICADOR:id {:
            Identificador ident = new Identificador(id);
            imprimirEtiqueta(ident);
            RESULT = ident;
        :} |
        invocacion_funcion:invo {:
            RESULT = invo;
        :} |
        PAR_ABRE expresion:expr PAR_CIERRA {:
            RESULT = expr;
        :};

literal ::=
        LIT_ENTERO:litInt {:
            Literal lit = new Literal(litInt, Tipo.INTEGER);
            imprimirEtiqueta(lit);
            RESULT = lit;
        :} |
        LIT_FLOTANTE:litFloat {:
            Literal lit = new Literal(litFloat, Tipo.FLOAT);
            imprimirEtiqueta(lit);
            RESULT = lit;
        :} |
        LIT_BOOLEANO:litBoolean {:
            Literal lit = new Literal(litBoolean, Tipo.BOOLEAN);
            imprimirEtiqueta(lit);
            RESULT = lit;
        :};

invocacion_funcion ::=
        PR_WRITELN:nombreFun PAR_ABRE expresion:expr PAR_CIERRA {:
            ArrayList<Expresion> params = new ArrayList<>();
            params.add(expr);
            RESULT = new InvocacionFuncion(nombreFun, params, Tipo.UNKNOWN);
        :} |
        PR_WRITELN:nombreFun PAR_ABRE CADENA:c PAR_CIERRA {:
            ArrayList<Expresion> params = new ArrayList<>();
            params.add(new Cadena("\\\"" + c + "\\\""));
            RESULT = new InvocacionFuncion(nombreFun, params, Tipo.UNKNOWN);
        :} |
        PR_WRITE:nombreFun PAR_ABRE expresion:expr PAR_CIERRA {:
            ArrayList<Expresion> params = new ArrayList<>();
            params.add(expr);
            RESULT = new InvocacionFuncion(nombreFun, params, Tipo.UNKNOWN);
        :} |
        PR_WRITE:nombreFun PAR_ABRE CADENA:c PAR_CIERRA {:
            ArrayList<Expresion> params = new ArrayList<>();
            params.add(new Cadena("\\\"" + c + "\\\""));
            RESULT = new InvocacionFuncion(nombreFun, params, Tipo.UNKNOWN);
        :} |
        PR_READ_INTEGER:nombreFun PAR_ABRE PAR_CIERRA {:
            InvocacionFuncion invo = new InvocacionFuncion(nombreFun, Tipo.INTEGER);
            imprimirEtiqueta(invo);
            RESULT = invo;
        :} |
        PR_READ_FLOAT:nombreFun PAR_ABRE PAR_CIERRA {:
            InvocacionFuncion invo = new InvocacionFuncion(nombreFun, Tipo.FLOAT);
            imprimirEtiqueta(invo);
            RESULT = invo;
        :} |
        PR_READ_BOOLEAN:nombreFun PAR_ABRE PAR_CIERRA {:
            InvocacionFuncion invo = new InvocacionFuncion(nombreFun, Tipo.BOOLEAN);
            imprimirEtiqueta(invo);
            RESULT = invo;
        :} |
        IDENTIFICADOR:nombreFun PAR_ABRE lst_args:args PAR_CIERRA {:
            final boolean esPredefinida = false;
            InvocacionFuncion invo = new InvocacionFuncion(nombreFun, args, Tipo.UNKNOWN, esPredefinida);
            imprimirEtiqueta(invo);
            RESULT = invo;
        :};

// Expresiones que se pasan como parámetro a una función
lst_args ::=
        lst_args:args COMA expresion:arg {:
            args.add(arg);
            RESULT = args;
        :} |
        expresion:arg {:
            ArrayList<Expresion> args = new ArrayList<>();
            args.add(arg);
            RESULT = args;
        :} |
        {:
            // Para que acepte la producción cuando no se pasa ningún argumento,
            // y a la vez genere una lista vacía para pasarle al constructor.
            ArrayList<Expresion> args = new ArrayList<>();
            RESULT = args;
        :};
